#### 基础语法展示


```python
"""
这里是一些基础的语法展示
"""
print(314) # 输出整型
print(3.14) # 输出浮点型
print("你好") # 输出字符串
money=0
money+=10
print("余额为:",money,"元")
```

#### 查看类型-type()语句
	(字面量或者变量)//返回值是一个表示对应类型的字符串(带有class字样)
```python
print(type(2))
type_money=type(money)
```

#### 强制转换类型-int()float()str()
	(字面量或者变量)//返回值是转换类型之后的数值
```python
int_str=str(314) # 将314转换成字符串
float_str=str(3.14) # 将3.14转换成字符串
float_int=int(3.14) # 将3.14转换成整型(注意会丢失精度)
int_float=float(314) # 将314转换成浮点型
str_int=int(input())
```
	进制转换
```python
print(int('123',8)) # 1*8^2+2*8^1+3*8^0=83 
```
	`int()` 函数还有一个可选参数 `base`，用于指定输入的数字的进制。例如，`int('123', 8)` 的结果是 `83`，因为 `'123'` 被解释为 8 进制数
```python
str([1,2,3] # 结果并非转换成字符串"123",而是字符串"[1,2,3]"
 list(str([1,2,3])) != [1,2,3]  # 因此list((str([1,2,3]))会变成
 ['[', '1', ',', ' ', '2', ',', ' ', '3', ']']
```
#### 运算符的不同
	求整除(//)  整除后获得除法运算结果中商的整数部分——取整除赋值(//=)
	求指数(**)  优先级极高,仅次于括号——取幂赋值(**=)
	
```python
print("10整除3是",10//3) # 答案是3
print("2的2次方是",2**2) # 答案是4
num=10
num**=2 # 10的10次方答案是100
num//=50 # 100整除50答案是2

-2**4 # 结果是-16而不是16,因为**的优先级高于-
```
#### 转义字符的使用
	可通过嵌套单双引号进行转义
	或者字符  
```python
print("'你好世界'") # 输出了两个单引号
print('"你好世界"') # 输出了两个双引号
print("\'") # 输出一个单引号
print("\"") # 输出一个双引号
```

#### 格式化
	百分号%作为占位符
	%s即为字符串填入格式,如果变量数据是一个数字,就会被转换成字符串
	%d将内容转换成整型,放入占位
	%f将内容转换成浮点型,放入占位 
	要占位的内容使用普通括号括起来((((((((((()))))))))))
```python
world="世界"
message="你好%s"%world
print(message) # 输出结果即为"你好世界" 

number=100 
avg_salary=3500.00
print("人数统计有%s,平均工资有%s"%(number,avg_salary)) # 全部转换成字符串
print("人数统计有%d,平均工资有%f"%(number,avg_salary)) # 原格式
```

#### 数字精度控制
	m控制宽度(宽度小于数字本身时不生效,宽度大于数字本身会在数字前生成相应位数的空格)
	.n控制小数点精度(会进行小数的四舍五入)
	例如: %5d(表示将整数的宽度控制为5)
	例如: %5.2f(表示将小数[是包括整数部分和小数部分]的宽度控制为5,小数点精度设置为2)

#### 速速格式化 新语法 f(format)
	f"内容{变量}" 不做任何精度要求,也不做任何格式要求
	要占位的内容使用大括号括起来{{{{{{{{{{{{}}}}}}}}}}}}
```python
print(f"我是{name},今年{age}岁")
```
	有具体结果的代码语句就是表达式 
	括号里可以是有执行结果的表达式,而不仅仅只有变量和字面量
```python
print("1*2的结果是%d"%(1*2))
print(f"1*2的结果是{1*2}")
print("字符串的类型名是%"%(type(str)))
```
#### format()输出语句使用
	d,b,o,x,X,c分别表示十进制,二进制,八进制和十六进制输出整数和字符
	f,e,g(F,E,G)分别用小数形式,科学计数和自动判定来输出浮点数
	',f'可以在输出浮点数的数带上千分位符
```python
print(format(95,'X'),format(95,'o')) # 其他投稿人
print(format(31416.123,',f')) # 此时结果是31,416.123000
```
	在输出宽度前可用>,<,^分别表示左对齐，右对齐以及居中对齐
```python
print(format('aaa','<10'),'|',
	  format('aaa','^10'),'|',
	  format('aaa','>10'),'|') 
# 结果是 |aaa  | aaa |   aaa|
```
	在输出宽度前可用+号来代表表示正数,用0表示向左边补0,不写则默认向左边补空格
```python
print(format(2,11,'10'),
	  format(2.11,'010'),
	  format(2.11,'+10'))
# 结果是         2.11   00000002.11   +2.11
```

#### 字符串输入语句 input()
	读取键盘输入,使用一个变量接收即可(获得的数据永远都是字符串)
	input(提示信息) 代替提前写一个print在前面
```python
name=input()
name=input("请告诉我你是谁") #input括号内可以写一个提醒的字符串或数字
age=input()
age=int(age) # 可以将input进的age字符串转换成整型
```
#### 前缀控制符r来格式化 原始字符串的使用
	前缀控制符r或者R，来简化定义符(引号)和转义符(右斜杠)
```python
print(r'a\n2') >>> a\n2
print('a\n2') >>> a (换行) 2
```

#### 引号内的特殊字符形成
	三引号内的字符串可以直接按Enter键换行,会自动补全一个\n字符
	单引号和双引号之间的字符串也可以换行,行末输入一个'\'就可以换下一行输入,但不会形成\n字符
```python
print('''12
34
56''') # 输出结果换行 即12(换行)34(换行)56

print("12\
34\
56") # 输出结果不会带上那个'\',即123456
```

#### 比较运算符和布尔类型
	用比较运算符运算的结果是布尔类型的字面量True和False(即1和0)
	布尔类型可以进行变量定义,直接使用字面量True和False
	None以及各种数值类型中的0,都会被当成False
	空字符串"",空元组(),空列表[],空字典{},空集合等等都被当成False
	注意: 当成不代表等于
```python
zhengque=True
cuowu=False
result=10>5 
print(zhengque,type(zhengque)) # 分别显示"True"和"<class'bool'>"
print(result,type(result)) # 分别显示"True"和"<class'bool'>"
```

#### if-elif-else判断语句
	if之后的条件是不需要括号的,但是最后面一定要加上引号
	通过缩进加换行来判断语句组的归属,嵌套同样适用
	else可以省略,此时效果就会变成一个个独立的if判断
	if not 就相当于c语言中的!(非运算),后面加的条件必须
```python
if int(input("输入身高:"))<175:
	print("身高符合要求")
	if int(input("输入体重:"))<100:
		print("体重符合要求")
	else 
		print("体重不符合要求")
		#此处来个换行
elif int(input("输入年龄"))<5:
	print("年龄符合要求")
else:
	print("年龄或身高不符合要求")
    # 此处来个换行
print(nb) # nb一定会被输出
```
	反斜杠`\`用于将一行长代码拆分成多行。
	它用于指示该行应继续到下一行。在您提供的代码中，反斜杠用于将`if`语句拆分为两行
```python
def is_crash(self):
	if \
	self.snake[-1][0] <= -250 or self.snake[-1][0] >= 240 or self.snake[-1][1] <= -240 or self.snake[-1][1] >= 260:
		return True
	elif self.snake[-1] in self.snake[:-1]:
		return True
	else:
		False
```
         
#### while循环语句
	while之后的条件同样不需要括号，但是最后面一定要加上引号
```python
i=0
while i<100:
	print()
	i+=1 # 终止条件
else:
	print(i) # 结果是100

i=1
sum=0
while i<=100:
    sum+=i
    i+=1
print(f"sum={sum}") # 答案是 1+2+3一直加到100的结果

```

#### for-in循环语句
	for 循环变量 in 待处理数据集(指字符串,列表,元组)
	和while循环不用,for循环无法设置循环条件,中止取决于数据集的多少
	for-else语句中,for结束循环后会执行else语句
	注意: 是因为容器内所有元素都被遍历了一遍而终止,而非break语句
```python
## 循环字符串
name="HelloWorld"
x=0 # 这里是因为for结束后又用了x,为了规范所以需要提前定义
for x in name: # 将字符串name的字符挨个取出,将其赋给临时变量x
	print(x)   #此时会将"HelloWorld"一个一个换行打印出来
print(x) # 此时for结束后的这个临时变量x的值是最后一个字符

for i in range(1,101):
	for j in range(1,11):

```

#### try,except语句
```python
try:
    # 可能发生异常的代码块
    ...
except SomeException:
    # 异常处理逻辑
    ...
finally:
    # 无论是否发生异常都会执行的代码块
    ...

```

```python
try:
    # 可能发生异常的代码块
    ...
except SomeException:
    # 异常处理逻辑
    ...
else:
    # 在没有异常发生时执行的代码块
    ...
```

#### and or not语句
	比较有意思的是,两者and,是取后者，两者or，是取前者
	其次在优先级上,not > and > or。当not和and及or在一起运算时，not的优先级最高
```python
4 or 5 #结果是4
5 or 4 #结果是5
4 and 5 #结果是5
5 and 4 #结果是4

5 and y!=8 or 0 # 结果是True
y!=8 and 5 or 0 # 结果是5
not 5 # 结果是False
5 or False # 结果是5
```

#### import()语句引用库函数
	语句: 
	import 模块1,模块二 as 别名1,模块N as 别名N
	模块名(别名).函数名(参数)
```python
import time,random as r
time.sleep(3) # 程序休眠3秒
r.randint(1,10) # 生成一个1-10的随机整数
```
	语句: from 模块名 import 函数名(参数)
```python
from time import sleep
from random import randint as ri
sleep(3)
ri(1,10) # 效果同上
```
	语句: form 模块名 import *
	该语句导入指定模块的所有函数,导入后可以直接调用库内的所有函数
```python
from time improt *
sleep(3)
```

#### 随机函数random()
	姑且先知道长啥样吧,random.randint(a.b),  其中参数a是下限，参数b是上限，生成的随机数n: a <= n <= b。
```python
import random # 声明
num=random.randint(1,100) #提供1~100的随机数
#注意randint需要两个参数

my_list=list(range(20)) #获得一个包含1~20的有序列表
random.shuffle(my_list) # 将列表里的20个元素随机打散
```

#### end=' '和sep=' '
	与c语言需要转义\n进行换行相反的是,python会自动换行
	print(\t)或者print()都可以实现换行
		当不需要换行的时候,可以进行一个end空字符添加来进行不换行操作
	当然不换行的同时,可以自己选择结尾的字符或者字符串
```python
print("Hello",end='')
print("world",end='')

for c in "abcd":
	print(c,end="*") #a*b*c*d*
```
	其次还有个sep语句来用于指定分隔符的参数，通常在输出函数中使用，例如`print()`函数。`sep`代表separator（分隔符）的缩写，它用于在打印多个值时在它们之间插入一个特定的字符或字符串。你还可以将`sep`参数设置为空字符串，以便在打印值之间不插入任何分隔符：
```python
print(1, 2, 3, sep=’:’) 
# 结果是1:2:3
print('Hello', 'world', sep=',')
# 输出: Hello,world
print('one', 'two', 'three', sep='-')
# 输出: one-two-three
print('apple', 'banana', 'orange', sep=' | ')
# 输出: apple | banana | orange
print('Hello', 'world', sep='')
# 输出: Helloworld
print(1, 2, 3, sep='')
# 输出: 123
```

#### 实现自动对齐
	转义\t相当于tab键输入一次
	可以使输出的内容进行缩进对齐的操作
```python
print("Hello\tworld")
```

#### range数字序列语句
	range(num) 
		该可迭代对象可获取一个从0开始,到num结束的数字序列(不包括num本身)
	range(num1,num2) 
		该可迭代对象获取一个num1开始,到num2结束的数字序列(不包括num2本身)
	range(num1,num2,step) 
		该可迭代对象获取一个从num1开始,到num2结束的数字间隔序列(不包括num2本身)
		如果step为负数则表示反着迭代
```python
range(10) # 获得数据为[0,1,2,3,4,5,6,7,8,9]
range(5,10) # 获得数据为[5,6,7,8,9]
range(5,10,2) # 获得数据为[5,7,9]
range(10,-1,-1) # 获得数据为[10,9,8,7,6,5,4,3,2,1,0]
for x in range(10): # 从该迭代器里取数
	print(x) # 此时会将[0,1,2,3,4,5,6,7,8,9]一个一个换行打印出来

a=range(20)
print(a) # 结果是range(20),仅仅表示一个从0开始到20结束的可迭代对象
a=list(range(20))
print(a) # 结果是[1,2,3,4,5,6,...,19,20],此时才把迭代器转换成列表
```

#### continue&break语句
	在嵌套循环中,只能作用在所在的循环上,无法对上层循环起作用
	continue是中断,break是中止

#### def关键字定义函数
	def 函数名(传入形参):
		函数体 # 使用实参
		return 返回值 
	# 返回值和传入参数都可省略
	下列是字符串长度计算函数
```python
def my_len(data)
	count=0
	for i in data:
		count+=1
	print(f"字符串{data}的长度是{count}")
```

#### None类型
	相当于c的void
	用于if判断中,None等同于False
	用于赋值给暂时无需具体值的变量
```python

def say():
	print("helloworld")
	return None # 可以省略
result=say() 
print(result) # 结果是None
print(type(result)) # 结果是<class 'NoneType'>

if not result: # 如果result为None即可执行该if语句
	print("nb")

x = None # 该变量暂时不想给初始值,暂时用None代替一下
```

#### param函数说明文档语句
	:param 变量:内容
	左右都有个引号,目前位置其他语句都是右边有引号,这个语句左边也要求有
```python
def func(x,y):
	"""
	:param x: 形参说明
	:param y: 形参说明
	:return: 返回值锁门
	"""
	return x+y
```

#### global关键字声明
	可以实现在函数内修改到函数外的变量
	只能在函数块使用
	语句块内不需要global来重新声明全局变量(即直接可以修改语句块外的全局变量)
```python
num=1
def test_a()
	num=2
def test_b()
	global num # 将形参声明成函数外的全局变量,此时就是同一个变量
	num=2
test_a()
print(num) # 此时还是1
test_b()
print(num) # 此时以及变为2了
```

#### 数据容器(数组的感觉)
	一个变量可以记录很多数据,每份数据称为一个元素
	每一个元素都可以是任意类型的数据,如字符串`数字`布尔等
	根据'是否支持重复''是否可修改''是否有序'分成五类
	列表(list)元组(tuple)字符串(str)集合(set)字典(dict)
```python
name_array=['你','好','世','界']
name_array=["你好","世界"]
name_array=[1,True,'1',"111"]
```

#### class关键字定义方法和使用
	方法和函数功能一致,有传入参数,有返回值,只是方法的使用格式不同
```python
#函数的定义
def add(x,y):
	return x+y
#方法的定义
class FUNC:
	def add(self,x,y):
		return x+y
# 函数的使用
num=add(1,2)
# 方法的使用
func=FUNC()
num=func.add(1,2)
```

#### list一览
![image.png](https://s2.loli.net/2023/06/05/ZxTq1pnbfY65Huc.png)
#### list()列表的定义和下标索引
	直接print列表的话会带上中括号
	注意下标越界
```python
# 字面量
[元素1,元素2,元素3,元素4,元素5,...]
# 定义变量接收非空列表
name=[元素1,元素2,元素3,元素4,元素5,...]
# 定义变量接收空列表
name=[]
name=list()
# 定义嵌套列表
name=[[1,2,3],[4,5,6]] # 一个列表两个元素,元素类型都是列表


#创建一个长度为1的列表，初始值为0
my_list = [0]
# 创建一个长度为5的列表，初始值为None
my_list = [None] * 5
# 创建一个长度为10的列表，初始值为0
my_list = [0] * 10
# 创建一个长度为3的空列表
my_list = [None] * 3

print(name[0]) # 取出第一个元素
print(name[-1],name[-2]) # 取出最后一个和倒数第二个元素
print(name[0][0]) # 取出第一个元素(该元素是列表),再取出该元素的第一个元素
print(type(name)) # 结果为<class'list'>
```

#### list的直接比较和直接赋值
```python
list01 = [1,2,3]  
list02 = list01  
list01[1] = 100  
print( list02) #因此，输出结果为[1, 100, 3]
```
	这段代码创建了一个名为list01的列表，其中包含1、2和3三个元素。然后，将list01赋值给list02。接下来，将list01的第二个元素更改为100。最后，打印出list02的值。由于list02是list01的副本，因此更改list01的值会影响list02的值。

	Python中的列表可以直接和列表比较。
	如果两个列表的元素相同且顺序相同，则它们是相等的。可以使用“==”运算符进行比较。

#### list内置<索引方法index()>的使用 
	语法: 列表名.index(元素)
	寻找这个元素,如果元素存在会返回索引值,否则则报错
	如果要寻找的哪个数据重复了,就会返回第一个的下标索引值
```python
mylist=['H','e','l','l','o']
index=mylist.index(input()) # 列表方法的内置函数判断输入的字符索引值
print(f"index={index}") 
```

#### list内置<插入方法insert()>的使用 ⬅️
	语法: 列表名.insert(下标,元素) # 通常用该方法将元素置前
	无返回值,直接操作
```python
mylist=['1','3']
mylist.insert(input(输入下标),input(插入的元素))
print(mylist)
```

#### list内置<追加方法append()和extend()>的使用 ⬅️
	语法: 列表名.append(元素) # 将内容追加到列表尾部
	语法: 列表名.extend(数据容器) # 将容器内容取出,依次追加到列表尾部(注意是谁加到谁后面)
```python
mylist=[6]
anotherlist=[1,2,3]

mylist.append(6)
print(mylist) # 结果是 [6,6]
mylist.extend(anotherlist)
print(mylist) # 结果是 [6,6,1,2,3]

print(len(mylist)) # 结果是5
mylist.append([7,8]) # 此时结果是 [6,6,1,2,3,[7,8]]
print(len(mylist) # 追加的列表[7,8]是一个元素,因此结果是6
```

#### list内置<剪切方法pop()>以及相关函数del()的使用 ⬅️
	语法: 列表名.pop(下标) # 将列表中的指定元素剪切出去
	语法: del 列表[下标] # 删除列表中的指定元素
	del删除的是变量，而不是数据。
	del可以删除列表中指定位置的元素；是根据索引（元素所在位置）来删除的
	pop可以剪切出去指定元素,并可以利用变量来接受返回值(即粘贴该元素),pop有弹出之意,不填默认最后一个
```python
mylist=[6,6,6]
del mylist[0] # 删除第一个元素
outnum=mylist.pop(2) # 取出第三个元素并粘贴到outnum变量
```

#### list内置<删除方法remove()和clear()>的使用 ⬅️
	语法: 列表名.remove(元素) 
	语法: 列表名.clear()
	remove删除某元素在列表中的第一个匹配项,这是按元素删除,而非pop和del的按下标删除
	注意: remove之后,列表为了避免出现空隙,会进行内存缩减,后面的会往前
	clear直接清空列表元素
```python
mylist=[1,2,3,4,3]
mylist.remove(3)
print(mylist) # 结果是[1,2,4,3]
mylist.clear()
print(mylist) # 结果是[ ]
```

#### list内置<统计方法count()>以及相关函数len()的使用 ⬅️
	语法: 列表名.count(元素)
	语法: len(列表名)
	count统计某一个元素在列表内的数量,无则返回0
	len统计列表元素总数量
```python
mylist=[1,2,3,4,1]
count=mylist.count(1) 
print(count) # 结果是2
print(len(mylist)) # 结果是5
```

#### list内置<浅复制方法 copy()>的使用✅
	语法: 列表名.copy()
	会返回一个新的一模一样的列表
	生成一个新的列表,并原列表所有元素的引用复制到新的列表中
```python
my_list=[1,2,3]
new_list=my_list.copy()
my_list[0]=0
print(new_list[0]) # 改变mylist元素不改变newlist
```

#### list内置<反转方法 reverse()> 的使用⬅️
	语法: 列表名.reverse()
	这是个原地操作,会改变原本序列
```python
my_list = [1, 2, 3, 4]
my_list.reverse()
print(my_list)  # 输出: [4, 3, 2, 1]
```

#### while&for进行有序的数据容器(序列)遍历
	定一个变量表示下标,从0开始
	循环条件:下标索引值<列表的元素数量(不能包含)
	while可以自定循环条件并做到无限循环,适用于任何想要循环的场景
	for理论上不可以无限循环,因为被遍历的容器容量不是无限的,适用于简单固定次数
	注意,后续的set集合遍历就只能for来遍历
```python
index=0 # 首先定义一个整型索引值0出来
mylist=[1,2,3,4,5,6]
while index<len(mylist):
	print(mylist[index])
	index+=1
# 此时会将列表中的元素依次换行打出 

for elem in mylist:
	print(elem)
# 此时会将列表中的元素依次换行打出 
```

#### tuple一览
#### tuple()元组的定义和下标索引
	列表可以修改，但是元组一旦定义完成就不可修改,元组可以看成只读的列表
	适用于在程序内封装数据又不希望数据被篡改时
	元组嵌套的列表,其内部的元素个数不变,但元素内容可变
```python
# 定义字面量
(1,"Hello",True)
# 定义变量接收非空元组
t1=(1,"Hello",True)
t2=(1,) # 必须要加一个逗号
# 定义变量接收空元组
t3=()
t4=tuple()
# 元组嵌套
t5=((1,2,3),(4,5,6))  # 元组套元组
t6=([1,2,3],[4,5,6])  # 元组套列表
t6[0][0]=0 # 将元组中的第一个元素(列表)的第一个元素改成0
elem=t6[0][0] 
print(elem) # 结果是0

```
	任何一组用逗号分隔的数据都会被系统默认为元组
```python
s=3+7,9//2,'Y',True
print(s) # 结果是 (10,4,'Y',True)
```

#### tuple内置<方法count()index()>以及相关函数len()的使用
	在tuple中只可以使用两个内置方法<count()><index()>
```python
t1=(1,"Hello",True)
t2=(1,) # 必须要加一个逗号
index=t1.index("Hello") # 值是1,因为Hello这个字符串在t1中是第二个
count=t2.count(1) # 值是1,因为1这个整型在t2中只有一个
num=len(t5) # 值是2,因为t5总共两个元素(这两个元素也是元组)
```

#### str一览
![image.png](https://s2.loli.net/2023/06/05/4MO2sSaDoIdWAji.png)
#### str()字符串的定义和下标索引
	字符串和元组一样,只读,不可修改
	index方法寻找字符串中的字符串时,会索引其第一个字母的下标
	count方法统计字符串中的字符串时,不会将要统计的字符串拆开成单个字符进行统计
```python
mystr="Hello world" # 就这样简简单单
value=mystr[0] # 值为'H'
value=mystr[-1] # 值为'd'

index=mystr.index('H') # 其值是0
index=mystr.index("world") # 其值是6
count=mystr.count("ll") # 其值是1
num=len(mystr) # 其值是11
```

#### str字符串<替换方法replace()>的使用✅
	语法: 字符串.replace(字符串1,字符串2)
	将字符串中的全部"字符串1"替换成"字符串2"
	可替换单个字符,包括空格等字符
	注意,不是修改字符串本身,而是返回得到一个新的字符串
```python
mystr="lijilin666"
new_mystr=mystr.replace("lijilin","LIJILIN") # 使用新的字符串变量来接收
print(mystr) # 结果仍然是lijilin666 并能没有被修改
print(new_mystr) # 结果是LIJILIN666
```

#### str字符串<分割方法split()>✅
	语法: 字符串.split(分隔符)
	按照指定的分隔符字符串,将字符串划分成多个字符串,并存入列表对象中
	注意,字符串本身不变,而是返回得到一个列表对象
```python
mystr="Hello world"
mystr_list=mystr.split('') # 按照空格切割
print(f"将字符串{mystr}经过split后变成{mystr_list}") 
# 结果是"Hello world"经过split后变成["Hello","world"]

mystr="你好,世界"
print(mystr.split(',')[1])
# 首先split掉','返回得到一个包含两个字符串元素的新列表,最后索引该新列表的其第一个元素"你好"

a,b="ABC.123".split(".")
# 结果是a为ABC，B为123
```

#### str字符串<前后规整方法strip()>的使用✅
	语法: 字符串.strip(字符串) 
	将字符串首尾的指定字符串规整(去除)掉,传入"12",就会将前后的'1'和'2'都移除
	这个方法的括号内字符串参数也可以省略不写,此时就是规整掉字符串首尾的空格
	注意: 字符串本身不变,而是返回得到一个新的字符串
```python
mystr0=" Helloworld  "
mystr1="21Helloworld121"
print(mystr0.strip())     # 结果是"Helloworld"
print(mystr1.strip("12")) # 结果是"Helloworld"
```
	语法: 字符串.rstrip(字符串) 字符串.lstrip(字符串)
	这个就可以指定只规整首还是尾,即right和left,左和右
```python
print(mystr1.rstrip("2"))
print(mystr1.lstrip("2"))
```

#### str字符串<大小写转换方法>的使用✅
	语法: 字符串.lower() 返回小写字符串
	语法: 字符串.upper() 返回大写字符串
	语法: 字符串.title() 返回所有单词首字母大写后的字符串
	语法: 字符串.capitalize() 返回只有首字母大写后的字符串
	语法: 字符串.swapcase() 返回大小写字母都转换一遍的字符串

#### str字符串<查找方法index()和find()和count>的使用
	语法: 字符串.index() 字符串.find() 
	返回一个字符串在另一个字符串中指定范围内首次出现的下标
	唯一区别是,找不到时,index方法会抛出异常,find()方法会返回-1
```python
my_string = "Hello, World!"
index1 = my_string.find("lo")  # 返回 3
index2 = my_string.find("Python")  # 返回 -1

my_string = "Hello, World!"
index1 = my_string.index("lo")  # 返回 3
index2 = my_string.index("Python")  # 引发 ValueError 异常

```
	语法: 字符串.rindex() 字符串.rfind() 
	和index(),find()的区别就是从右边找

	语法: 字符串.count() 返回一个字符串在另一个字符串中出现的次数

#### str字符串<对齐方法center()和just()>的使用✅
	语法: 字符串.center(宽度,'字符') 
	宽度大于原字符串时,返回一个居中对齐的字符串,否则返回原字符串
	参数字符可以决定左右两边填充什么字符
	语法: 字符串.rjust(宽度,'字符') 和字符串.ljust(宽度,'字符') 
	分别返回一个向右,向左对齐的新字符串
	参数字符可以分别决定左右两边填充什么字符

#### str字符串的大小比较
	字符串的对比就是一位一位的对比,利用ASCII码值
	一样的话就调到下一位,只要有一位大,就判定其大
	字符串按位⽐较，两个字符串第⼀位字符的ascii码谁⼤，字符串就⼤，不再⽐较后⾯的；第⼀个字符相同的情况下，就⽐第⼆个字符串，以此类推
	ASCII码是有规律的。记住两个关键 `A` 和 `0` 的ASCII值即可：`A=65` 小写比大写多32 `a=97``0=48`
	也就是说"阿拉伯数字"<"大写字母"<"小写字母"
```python
print("abc"<'c') # True
print("abb"<"abc") # True
print('a'>'A') # True
print("key1"<"key2") # True
print(2*'A'>'H') # False
```
	 2*'A’和’H’比较时，'AA’和’H’进行比较。由于 ‘A’ 的 ASCII 码值是 65，而 ‘H’ 的 ASCII 码值是 72，所以 ‘H’ 大于 ‘AA’。

#### str字符串的ASCII转换函数ord()和chr()
	語法: chr(整數) ord(字元)
	用於在整數和字元之間進行轉換。
	chr函數接受一個整數，返回對應的Unicode字元。
	ord函數接受一個字元，返回對應的Unicode編碼]
```python
print(chr(65)) # 輸出 A
print(ord("A")) # 輸出 65
```

#### str内置<连接方法join()>的使用✅
	语法: 分隔符.join(可迭代物件)
	可以將一個可迭代物件中的所有元素連接成一個字串。需要指定一個字串作為分隔符
```python
# 使用逗號作為分隔符，將一個列表中的元素連接成一個字串
my_list = ["apple", "banana", "cherry"]
my_string = ",".join(my_list)
print(my_string) # 輸出 apple,banana,cherry

# 使用空格作為分隔符，將一個元組中的元素連接成一個字串
my_tuple = ("hello", "world")
my_string = " ".join(my_tuple)
print(my_string) # 輸出 hello world
```

```python
"".join(‘asdssfff’.split(‘sd’))
# 输出 ’assfff’
```
#### str字符串常量
	需要引用stirng库
	string模块中的常量有以下几种：
```python
import string


-   "string.ascii_letters"  # 所有ASCII字母，包括大小写]
-   "string.ascii_lowercase" # 所有ASCII小写字母]
-   "string.ascii_uppercase" # 所有ASCII大写字母]
-   "string.digits" # 数字0~9
-   "string.hexdigits" # 十六进制数字0~9和a~f
-   "string.octdigits" # 八进制数字0~7
-   "string.punctuation" # 所有标点符号
-   "string.printable" # 所有可打印的字符，包括字母，数字，标点，空白等]
-   "string.whitespace" # 所有空白字符，包括空格，制表符，换行符等]
```

#### set()集合的定义
	和list和tuple还有str不同,set不支持重复元素
	set是无序的,所以集合不支持下标索引访问,因此序列不包含set
```python
# 定义字面量
{元素1,元素2,元素3,...}
# 定义变量来接收非空集
name={元素1,元素2,元素3,...}
# 定义变量来接收空集
name=set()
```

#### set集合的运算
	求并集(|),交集(&),差集(-),以及判断包含关系(>==<)
```python
set1={1,2,3,4,5}
set2={4,5,6,7,8}
set1|set2 # 结果是{1,2,3,4,5,6,7,8}
set1&set2 # 结果是{4,5}
set1-set2 # 结果是{1,2,3} (set1有但set2没有的 即减去了set2中set1有的元素)
set1==set2 # 结果是False 判断是否全部元素相同
set1<set2 # 结果是False 判断set1是不是set2的子集
```

#### set内置<添加方法add()>的使用⬅️
	语法: 集合名.add(元素)
	存在去重操作,如果集合内以及有重复元素,则会去重,没有的话才会加进来
```python
myset={"hello","world"}
myset.add("你好") # 会被成功add
myset.add("hello") # 并不会被成功add
print(myset) # myset的结果是{"hello","world","你好"} # 无序,不一定这样排
```

#### set内置<删除方法remove()和clear()>的使用⬅️
	语法: 集合名.remove(元素)
	直接操作,无需返回
```python
myset={"Hello","world"}
myset.remove("Hello") # 移除集合中的"Hello"
myset.clear() # 清空集合
print(myset) # 结果是set()表示空集合

```
#### set内置<剪切方法pop()>的使用⬅️
	语法: 集合名.pop()
	由于集合无序,但是pop这个方法又是需要索引值的,故在此会随机剪切
	返回一个集合中的随机元素,集合遭到修改,且元素被移除
```python
myset={'1',1,"666"}
elem=myset.pop() # 随机接收剪切出来的元素
print(elem) # 要么是字符1,要么是数字1,要么是字符串"666"
```

#### set内置<取差集方法difference()>的使用✅
	语法: 集合1.difference(集合2)
	取出集合1和集合2的差集(即集合1有但是集合2没有的元素)
	返回得到一个新的集合3,里面包含这些元素
```python
set1={1,2,3}
set2={1,5,6}
set3=set1.difference(set2)
print(set1) # 结果仍然是{1,2,3}
print(set2) # 结果仍然是{1,5,6}
print(set3) # 结果是{2,3} 因为这些set1有但是set2没有
```
#### set内置<消差集(取交集)方法difference_update()>的使用✅
	语法: 集合1.difference_update(集合2)
	在集合1中删除和集合2相同的元素
	返回值是被消除的差集,集合1被修改,集合2不变
```python
set1={1,2,3,4,5,6}
set2={6,7}
set1.difference_update(set2)
print(set1) # 结果为{1,2,3,4,5}
print(set2) # 结果为{6,7}
```
#### set内置<合并方法union()>的使用✅
	语法: 集合1.union(集合2)
	将集合1和集合2组合成新集合,如果存在重复元素将会在集合3中进行去重
	返回得到一个新的集合,但集合1和集合2不变
```python
set1={1,2,3}
set2={1,4,5,6}
set3=set1.union(set2) 
print(set1) # 结果是{1,2,3}
print(set2) # 结果是{1,4,5,6}
print(set3) # 结果是{1,2,3,4,5,6}
```

#### dict()字典的定义和键索引
	Key:Value (即 键:值)
	字典中的元素都是一对一对的数据,称作键值对
	字典不允许key的重复,和集合一样,会去重
	字典没有下标,故通过key去索引其内容
```python
# 定义字面量
{key:value,key:value,key:value,...}
# 定义变量接收非空字典
mydict={key:value,key:value,key:value,...}
# 定义变量接收空字典
mydict={}
mydict=dict{}
# 键索引 
mydict1={1:"66","nb":6,'r':'6'}
print(mydict1[1]) # 结果是"66"
print(mydict1["nb"]) # 结果是6
print(mydict1['r']) # 结果是'6'
```
	key和value可以为任何数据类型(但key不能为字典)
	由于value可以为字典,故可以进行字典的嵌套
```python
stu_score_dict=
{
	"beta":{
			"CHI":89,
			"MAT":100,
			"ENG":33,
			},
	"iota":{
			"CHI":100,
			"MAT":50,
			"ENG":100}
}

print(stu_score_dict) # 结果是{"beta":{...},"iota":{...}}
print(stu_score_dict["beta"]["CHI"]) # 结果是89
```
#### dict字典的新增和更新⬅️
	语法: 字典名[Key]=Value 
	先索引到具体的键值对,接着进行赋值操作,此时字典遭到修改,元素被新增或者更新
	如果原先没有该Key,则此时操作即为新增
	如果原先就有该Key,则此时操作即为更新
```python
mydict={"iota":1,"beta":2}
mydict["iota"]=0
mydict["kappa"]=3 
print(mydict) # 此时内容是{iota:0,beta:2,kappa:3}
```

```python
a = ['sno', 'sname', 'score']
b = ['1910299321', 'Tom', '98']
newdict=dict()
for i in range(3): # 0~2
    newdict[a[i]]=b[i]
print("\n",newdict)
#此时内容是 
#{'sno': '1910299321', 'sname': 'Tom', 'score': '98'}
```

#### dict内置<剪切方法pop()和删除方法clear()>的使用⬅️
	语法: 字典名.pop(Key)
	返回获得指定Key的Value,同时字典被修改,且指定Key的Value被删除
	语法: 字典名.clear()
	直接清空字典里的键值对
```python
mydict={"iota":1,"beta":2}
print(mydict.pop("iota")) # 此时内容为1
print(mydict) # 内容为{"beta":2}
```

#### dict内置<获取方法keys()>的使用以及字典的遍历✅
	语法: 字典名.keys()
	获得字典中的全部键,即所有keys,返回得到一个新的列表
```python
mydict={"iota":1,"beta":2}
keys_list=mydict.keys()
print(keys_list) # 结果是["iota","beta"]
```
	获取完keys的列表可以作为for遍历时的数据容器
	其实还可以直接对字典进行遍历,此时是对key进行遍历
```python
for key in keys_list: # 对keys()后的列表进行遍历
	print(f"此时的key是:{key}")
	print(f"此时的value是:{mydict[key]}")
for key in mydict: # 直接对字典进行遍历
	print(f"此时的key是:{key}")
	print(f"此时的value是:{mydict[key]}")
```
#### dict内置<获取方法items()>的使用以及字典的遍历✅
	语法: 字典名.items()
	获得字典中的全部键值对,即所有 keys:value ,返回得到一个新的可迭代对象
	该可迭代对象需要转换成list,才能访问其内部键值对
	转换成列表之后,里面是可遍历的包含(键,值)的元组
	在循环遍历时可用一个(item)或两个(key,value)变量去接收迭代器items
```python
dict1={'a':1,'b':2,'c'=3}
list(dict1.items()) # 结果是一个列表[('a',1),('b',2),('c',3)]

for key,value in result.items() #key和value去遍历接收items()的键值对
	print(key,":",value)

for item in result.items: # 只用一个item去接收items()中一个一个元组
	print(item)  # 结果是键值对以一个一个元组的形式打印
```
#### dict内置<获取方法get()>的使用
	语法:字典.get(鍵名, 預設值)
	[返回指定鍵的值。如果鍵不存在，它可以返回一個預設值(默认为None)，而不會引發錯誤]
```python
car = {"brand": "Ford", "model": "Mustang", "year": 1964}
# 使用get函數來獲取鍵的值
x = car.get("model")
print(x) # 輸出 Mustang
```

#### dict实现缺失语句: switch-case的字典补充
	Python没有像其他编程语言（如Java和C++）中的switch语句那样的直接结构。
	但是，您可以使用Python的字典（Dictionary）来实现类似switch的功能。下面是一个示例

```python
def switch_case(case):     
	switcher = 
	{         
		0: "Case 0",         
		1: "Case 1",         
		2: "Case 2"     
	}     
	return switcher.get(case, "Invalid Case")`
```
	在这个例子中，我们定义了一个名为`switch_case`的函数，它接受一个参数`case`。
	然后，我们创建了一个字典`switcher`，其中包含每种情况的值。
	最后，我们使用字典的`get()`方法，如果没有匹配的情况，则返回“Invalid Case”。
	您可以像这样调用`switch_case()`函数：
```python
print(switch_case(1)) # 输出 "Case 1" print(switch_case(3)) # 输出 "Invalid Case"`
```
	传递1时，函数返回“Case 1”。传递3时，函数返回“Invalid Case”，因为该字典中没有对应于情况3的值。

#### set集合和dict字典有关于函数len()的使用
	语法: len(集合名or字典名)
	如果有重复元素(其实这样定义集合就是错误的吧),此时重复元素不计数
	返回集合或字典中非重复元素的总数
```python
set={0,0,0,0,1}
num=len(set)
print(num) # 结果是2,那些重复的0仅记作一个

dict={"iota":1,"beta":2}
num=len(dict)
print(num) # 结果是2
```


#### 序列的定义和常用操作<切片> 即"留意序列置后的中括号"
	序列指"有序""连续"的数据容器,例如<列表><元组><字符串>
	序列均支持<切片>操作,切片指"从一个序列中取出一个子序列"
	语法: 序列名[ 起始下标 : 结束下标 : 步长 ] 
	中括号＋引号是切片的标志
	1.起始下标可以留空,表示从头开始
	2.结束下标(不含本身),也可以留空,表示一直切到结尾
	3.步长为1,则一个一个切;步长为N,表示每次跳过N-1个切;步长为负,表示反向切
	注意,起始下标和结束下标也要反向标记
	注意,切片操作不会影响序列本身,而是会得到以一个新的序列(是为了照顾字符串和元组)
```python
mylist=[0,1,2,3,4,5,6,7,8,9]
newlist=mylist[1:4] # 指从第二个开始切到第五个,步长是1故保持默认,省略不写
print(newlist) # nwelist结果是[0,1,2,3,4]

mytuple=(0,1,2,3,4,5,6,7,8,9)
newtuple=mytuple[:] # 指从头切到尾,(类似复制)步长省略不写即保持默认
print(newtuple) # newtuple结果是(0,1,2,3,4,5,6,7,8,9)

mystr="0123456789"
newstr=mystr[::2] # 指从头切到尾,但步长是二,即隔一个进行切片
print(newstr) # newstr的结果是"02468"

mystr="0123456789"
newstr=mystr[3:1:-1] # 指从第四个反向切到第二个结束(不包括第二个本身 )
print(newstr) # newstr的结果是"32" 注意,不包含1了

mytuple=(0,1,2,3,4,5,6,7,8,9)
newtuple=mytuple[::-2][1:3:] 
# 指从从头到尾反向切片,每隔一个进行切片,此时结果是(8,6,4,2,0)
# 进行二次切片,从第二个依次切到第四个(不包括第四个),此时结果是(6,4)
print(newtuple) # newtuple的结果是(6,4)
```

#### 数据容器的通用操作<大小判断><强制转换>
	语法: len(容器)可以返回获得容器中的元素总数,不过多介绍
	语法: max(容器)可以返回获得容器中最大的元素
	语法: min(容器)可以返回获得容器中最小的元素
```python
my_list=[1,2,3,4,5]
my_tuple=(1,2,3,4,5)
my_str="abcedfg"
my_set={1,2,3,4,5}
my_dict={"key1":1,"key2":2}

print(max(my_list)) # 结果是5
print(min(my_tuple)) # 结果是1
print(max(my_str) # 结果是g
print(min(my_set)) # 结果是1
print(min(my_dic)) # 结果是key1

```
	语法: list(容器名) tuple(容器名) str(容器名) set(容器名)
	会返回得到一个新的数据容器,而非修改原先的数据容器 
	只有ditc -> str时才会保留value值,但是连同中括号一起全部变成字符串了
	转换成 set 时要注意重复的元素会被去重
```python
list((1,2,3,4,5)) # (1,2,3,4,5)--->[1,2,3,4,5]
tuple("abcdefg") # "abcdefg"--->('a','b','c','d','e','f','g')

set=([1,1,3]) # [1,1,3]--->{1,3} 去重操作

my_dict={"key1":1,"key2":2}
set(my_dict) # {"key1":1,"key2":2}--->{"key1","key2"}
str(my_dict) # {"key1":1,"key2":2}--->["key1":1,"key2":2]
```

#### 数据容器的通用操作<排序> 以及方法sort()的使用
	sorted()是Python内置的一个排序函数，用于对序列进行排序，返回一个新的已排序序列。
```python
sorted(iterable, key=None, reverse=False)
```
	`iterable`表示需要排序的序列，可以是列表、元组或其他可迭代对象；
	`key`是一个可选参数，用于指定一个函数来从每个元素中提取用于排序的键；
	`reverse`是另一个可选参数，用于指定是否按照降序排序，默认为升序排序。

	sorted()函数返回的是一个新的已排序序列，不会改变原有序列

	`key`参数用于指定一个函数，这个函数将被应用到每个元素上，用于从元素中提取一个用于排序的键。例如，如果要按照列表中字符串长度进行排序，
```python
words = ["apple", "banana", "cherry", "date", "elderberry"]
sorted_words = sorted(words, key=len)
```
	注意: sort方法的使用,会直接修改数据容器,故元组字符串等数据容器不可用
```python
sorted(my_list) # [4,2,3,1,5] --> [1,2,3,4,5]
mylist.sort(reverse=True) # 降序
mylist.sort(reverse=False) # 升序(不填也是默认升序)
sorted(my_tuple) # (4,2,3,1,5) --> [1,2,3,4,5]
sorted(my_set) # {4,2,3,1,5} --> [1,2,3,4,5]
sorted(my_str) # "abcdefg" --> ['a','b','c','d','e','f','g'] 
sorted(my_dict) # {"key1":0,"key2":1} --> ["key1","key2"]
```
	除了sorted函数还有一个容器对象的sort方法
	语法: 容器名.sort(reverse)
	会返回得到一个按大小排好顺序的列表
	reverse参数如果不写则默认升序排列,如果写了reverse=True则变成降序排列
	
#### 数据容器的通用操作<压缩>以及方法zip()的使用
	语法: zip(容器名)
	它可以将多个可迭代的对象（如列表、元组、字典、集合、字符串等）作为参数
	将它们中对应的元素打包成一个个元组，然后返回一个由这些元组组成的对象
	注意: 是把多个容器所对应的元素进行打包,打包成一个一一对应的元组,最终多个元组构成列表
```python
name = ['iota','kappa','beta']
age = [18,19,20]
list(zip(name,age)) # 该结果是[('iota',18),('kappa',19),('beta',20)]
```
	你还可以用*号操作符，解压拆分成了两个列表，然后分别赋值给了name和age两个变量
```python
# *号把zip对象中的元组。
result = [('iota', 18), ('kappa', 19), ('beta', 20)]
name,age = zip(*result)
print(name) # (18, 19, 20)
print(age) # ('张三', '李四', '王五')
```

```python
a = [‘name’, ‘age’, ‘sex’]
b = [‘Dong’, 38, ‘Male’]

#请使用一个语句将这两个列表的内容转换为字典，并且以列表a中的元素为“键”，以列表b中的元素为“值”
c = dict(zip(a, b))
```
#### 数据容器的通用操作<求和>
`sum()` 是一个内置函数，在 Python 中用于计算可迭代对象（如列表、元组、集合等）中所有元素的总和。
```python
numbers = [1, 2, 3, 4, 5]
result = sum(numbers)
print(result)  # 输出: 15

# 可以使用 start 参数指定初始值
result = sum(numbers, start=10)
print(result)  # 输出: 25

# 也可以使用生成器表达式作为参数
result = sum(i**2 for i in range(1, 6))
print(result)  # 输出: 55

```

#### 数据容器的通用操作<链接>
在 Python 中，`tuple` 和 `list` 这样的有序容器类型可以使用 `+` 运算符进行相加操作，但是它们的行为稍有不同。对于 `list` 类型，`+` 运算符用于连接两个列表，返回一个新的列表，其中包含了两个原始列表的元素。示例如下：
```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]
result = list1 + list2
print(result)  # 输出: [1, 2, 3, 4, 5, 6]
```
而对于 `tuple` 类型，`+` 运算符同样用于连接两个元组，返回一个新的元组，其中包含了两个原始元组的元素。示例如下：
```python
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
result = tuple1 + tuple2
print(result)  # 输出: (1, 2, 3, 4, 5, 6)
```
需要注意的是，`+` 运算符不会修改原始的 `list` 或 `tuple`等 对象，而是创建一个新的对象作为结果返回。如果你想要修改原始对象，可以使用`+=` 运算符。
```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list1 += list2  # 修改了原始的 list1 对象
print(list1)  # 输出: [1, 2, 3, 4, 5, 6]

```
使用加号+也可以完成字符串的拼接，这种更为常见（可以字面量和变量，但字面量要求是字符串而非数字
```python
print("你好"+"世界")
str="世界"
print("你好"+str)
int=100
print("你好"+int) 
```
集合也支持使用 `+=` 运算符进行修改操作。它会将一个集合与另一个集合进行合并，从而修改原始集合。
```python
set1 = {1, 2, 3}
set2 = {4, 5, 6}
set1 |= set2  # 修改了原始的 set1 对象
print(set1)  # 输出: {1, 2, 3, 4, 5, 6}
```
需要注意的是,一旦创建了一个元组，就不能直接修改它的元素。不能使用 `+=` 运算符来修改一个元组。
当你尝试使用 `+=` 运算符修改一个元组时，会引发一个类型错误（TypeError），提示元组不支持这样的操作。以下是一个示例：
```python
tuple1 = (1, 2, 3)
tuple2 = (4, 5, 6)
tuple1 += tuple2  # 尝试修改元组，会引发 TypeError
```

#### 数据容器的通用操作<解包>
这种语法称为解包（Unpacking），它可以方便地将容器中的值分配给多个变量。
```python
a, b = [1, 2]
a, b = (1, 2)
a, b = {1, 2}
a, b = {"key1": 1, "key2": 2} # a将被赋值为"key1"对应的值1，b将被赋值为"key2"对应的值2。
a, b = "AB" # a='A',b='B'

mystr="Hello world"
a, b = mystr.split('') # a=Hello b=world
```
#### 数据容器的通用操作<重复>
乘号（`*`）用于重复容器中的元素。当乘号作用于容器和一个整数时，容器中的元素将重复指定的次数。例如：
```python
my_list = [1, 2, 3]
repeated_list = my_list * 3
print(repeated_list)  # 输出: [1, 2, 3, 1, 2, 3, 1, 2, 3]

my_string = "Hello"
repeated_string = my_string * 3
print(repeated_string)  # 输出: "HelloHelloHello"

my_tuple = (1,)
repeated_tuple = my_tuple * 4
print(repeated_tuple)  # 输出: (1,1,1,1)

my_set = {1, 2, 3}
repeated_set = my_set * 2
print(repeated_set)  # 抛出 TypeError: unsupported operand type(s) for *: 'set' and 'int'

```
#### 函数多返回值
	函数内分别返回语句: return x,y
	函数外多个变量分别接收多个返回值: x,y=函数名()
	总之通过逗号来实现多个返回值的操作
```python
def test()
	return 1,2
x,y=test()
print(x) # 结果1
print(y) # 结果2
```

#### 函数返回范围以返回bool类型
	The function `inside(head)` returns `-250<head<250` which is a boolean value. 
	It checks if the value of `head` is inside the range of -250 to 250. 
	If it is, then it returns `True`, otherwise it returns `False`.

```python
def inside(head):
	return -250<head<250
```
#### 函数的四种参数传递形式
- 位置传参:  
	调用函数时根据函数定义的参数位置来传递参数
```python
def info(name,age,gender):
	print(name,age,gender)

info("iota",16,"male")
```
- 关键字传参: 
	调用函数时通过"键=值"的形式传递参数,key是形参,value是实参
	可以无视顺序,只要对应好valeue就可以了
	如果位置和关键字混用时,位置参数必须在关键字参数前面,但关键字参数之间仍可以无序
```python
def info(name,age,gender):
	print(name,age,gender)

info(name="iota",age=16,gender="male")
info(age=16,gender="male",name="iota") 
info("iota",gender="male",age=16)
```
- 缺省传参(默认传参):  
	定义函数时就用"键=值"的形式,默认设置一个形式参数值
	默认参数必须统一写到定义的最后面
```python 
def info(name,age,gender="male"):
	print(name,age,gender)

info("iota",16) # 此时结果保持默认,gender是"male"
info("iota",16,"female") # 此时修改默认值
```
- 位置不定长传参(argument)
	:定义函数时使用"args"这个元组来接收传入的参数
	使用函数时可以无限传入元组args
```python
def info(*args): # 标志是 * 单星号
	print(*args)

info("iota")
info("iota","kappa",...)
```
- 关键字不定长传参(keyword-argument)
	定义函数时使用"键=值"的形式来让"kwargs"这个字典接收
	使用函数时同样可以无限传入字典kwargs
```python
def info(**kwargs): # 标志是 ** 双星号
	print(**kwargs)

info(name="iota",age=16,gender="male")
```
#### 函数作为参数传入其他函数
	函数本身可以作为参数传入另一个函数中进行使用
	传入一个计算逻辑代码而非数据
```python
def compute(x,y)
	return x+y
def test(compute)
	result=compute(1,2)
	print(result)
```
#### 关于函数作为参数和直接调用的区别
	add_params(a,b)，它的功能是返回 a 和 b 的和。
	mult_params(func,a,b,c)，它的功能是返回 func(a,b) 和 c 的乘积。
	如果想用 mult_params 函数来计算 (1+2)*3 的结果
	可以把 add_params 函数作为参数传递给 mult_params 函数，如下：

```python
def add_params(a,b):
    return a+b

def mult_params(func,a,b,c):
    return func(a,b)*c

r = mult_params(add_params,1,2,3)
print(r) # 输出 9
```

	这就是函数作为参数传递的方式。
	如果我们不想把 add_params 函数作为参数传递
	而是直接在 mult_params 函数里调用它，我们可以这样写：

```python
def add_params(a,b):
    return a+b

def mult_params(a,b,c):
    return add_params(a,b)*c

r = mult_params(1,2,3)
print(r) # 输出 9
```
	这就是直接调用函数的方式。
	两种方式得到的结果都是一样的，
	第一种方式更灵活，因为我们可以传递不同的函数作为参数，实现不同的功能。
	第二种方式更简单，因为我们不需要额外定义或传递参数，只需要调用已经定义好的函数。

#### 内嵌函数的使用
	在一个函数内部可以嵌套一个或多个函数
	函数及其定义的变量都有严格的作用域
	对于内层函数,局部变量都只能在该内部函数中使用,外层函数无法使用
```python
a=1
def outer():
	b=1
	print(a) # 可以打印
	def inner():
		c=1
		print("inner")
outer() # 可以运行
print(b,c) # 不可以打印
inner() # 抛出错误

```
#### lambad关键字定义匿名函数
	def关键字可以定义带有名称的函数,可重复使用
	lambda关键字可以定义匿名函数,只可临时使用一次(应用场景适用于简洁优雅)
	语法:  lambda 传入参数: 一行代码作为函数体
	注意,只能写一行,无法写多行代码,但是传入参数可以写很多
```python
def test(compute)
	result = compute(1,2)
	print(result)

test(lambda x,y: x+y) # 结果是3
```


#### 对象(object)
	python中的对象是一种数据结构，它有自己的属性和方法。
	属性是对象存储的数据，方法是对象可以执行的操作。
	对象可以是任何类型的值，比如整数、字符串、列表等。

#### 查看所有关键字(keyword)
	关键字不能用作变量名,函数名或类名等
	输入以下代码后,关键字将以列表的形式打印出来
```python
imort keyword
print(keyword.kwlist) # keyword 就是关键字
```

#### 哈希(hash)
	可哈希的数据类型，就是不可变的数据结构，比如数字、字符串、元组等
	可哈希的对象可以作为字典的键或集合的元素，因为它们有唯一的哈希值
	不可哈希的数据类型，就是可变的数据结构，比如列表、字典、集合等
	不可哈希的对象不能作为字典的键或集合的元素，因为它们没有唯一的哈希值

#### 单独的下划线
	单独的下划线是一个特殊的变量,用于表示上一次运算的结果
```python
100 # 他会直接输出100(这也算是一种运算了)
_+20 # 相当于100+20了
```

#### id()函数查看内存地址
	语法: id(obj)
	作用: 返回obj对象的内存地址
```python
x=3
id(x) # 结果是一串地址
```

#### 利用极小值判断实数是否相等
	可以看相减之后的绝对值是否小于一个极小值
```python
a=1.3
b=2.3-1
abs(a-b)<1e-10 # 结果是True或者False
```

```python
import math
1.11+1 # 结果是2.1100000000000003
math.isclose(2.11,1.11+1) # 结果是True
```

####  位运算
```
六种位运算符，由于底层, 所以性能更优
<< 左移：将一个数的二进制位向左移动指定的位数，右边补0。
\>\> 右移：将一个数的二进制位向右移动指定的位数，左边补0或1（取决于符号）。 	 
\~ 按位取反：将一个数的每个二进制位取反，即0变1，1变0。
& 按位与：将两个数的对应二进制位进行逻辑与运算，都为1时结果为1，否则为0。
| 按位或：将两个数的对应二进制位进行逻辑或运算，都为0时结果为0，否则为1。
^ 按位异或：将两个数的对应二进制位进行逻辑异或运算，即相同为0，不同为1。
```
	一些例子
```python
3 | 5 == 7  
3 & 6 == 2
3 << 2 == 12
65 >> 1 == 32
chr(ord(‘a’)^32) #结果是'A'
chr(ord(‘a’)-32) #同上
```

#### 多变量赋值
	语法: 变量1=变量2=变量3=值
	语法: 变量1,变量2,变量3=值1,值2,值3
```python
var1 = var2 =var3 = 1-2
var1,var2,var3=10%2,10//2,'ab'
```

#### 变量的共享引用(?)
	赋值操作时,要注意引用空间的共享现象,数据类型和字符串都是不可变数据
	接下来是int的例子,float的例子同理
```python
# int_sample

x=1
y=x
x,y # 结果是(1,1)
print(x is y,id(x)==id(y)) # 结果是两个True
x=2 # 此时x与y不再共享一个内存空间
print(x is y,id(x)==id(y)) # 结果是两个False
```

```python

# tuple_sample

x=(1,2,3)
y=x
x,y # 结果是((1,2,3),(1,2,3))
print(x is y,id(x)==id(y)) # 结果是两个True
x=(3,4,5) # 不可变数据类型只能查询,不能修改
print(x is y,id(x)==id(y)) # 结果是两个False

x=(1,2,[3,4]) 
y=x
x,y # 结果是((1,2,[3,4]),(1,2,[3,4]))
print(x is y,id(x)==id(y)) # 结果是两个True
x[2][0]=99 # 将元组中的列表元素修改之后,元组的位置并没有发生改变
x,y # 结果是((1,2,[99,4]),(1,2,[99,4]))
print(x is y,id(x)==id(y)) # 结果是两个True
```

#### eval()函数多数据同时输入以及其"输入即类型"的特质
	语法: eval(expression, globals, locals)
		第一个参数expression是一个表达式字符串
		而后面两个参数globals和locals是可选的参数，用来指定全局和局部变量
	eval()可以执行参数字符串中的表达式并返回表达式的值
	还可以通过complie()执行一个代码对象
	eval函數主要是用來實現python中各種數據類型與str之間的轉換
	输入的是字符串,被识别的可能不是字符串
	如果你有一个字符串，比如"1 + 2"
	你可以用eval()函数来计算它的值，就像在Python中直接写1 + 2一样
```python
a,b,c=eval(input('a,b,c=')) # 此时就可以分别输入不同类型的数据(但要注意用逗号分隔开)

a=eval(input("readin list:")) # 此时只要输入一个列表就会直接判断成列表
```
	也可以利用字符串的切片和map()函数实现多数据同时输入

#### map()函数实现可迭代对象的逐个返回
	语法: map(function, iterable,...)
	用来对一个可迭代对象中的每个元素应用一个函数，并返回一个新的可迭代对象
```python
x="123"
a,b,c=map(int,x) # 是一种解包赋值的写法
```
	它相当于把字符串x中的三个元素分别转换成整数，并赋值给a，b，c三个变量³
	字符串是一个可迭代对象，它可以被分解成单个字符
	而map函数就是对每个字符应用int函数，把它们转换成整数。
	(如果想把整个字符串作为一个数字来处理，用int函数来直接转换，而不是用map函数)
	在Python 2中，map函数会返回一个列表
	而在Python 3中，map函数会返回一个迭代器
```python
a,b,c=map(int, input(‘a,b,c:’).split())

a,b,c=map(float,eval(input(a,b,c=)))
```

#### enumerate()函数实现可迭代对象的枚举
	enumerate()函数用于将一个可迭代对象转换为一个枚举对象，
	该枚举对象包含了可迭代对象中的所有元素以及它们的索引(索引在前值在后)
	例如，对于列表a = [1, 2, 3]，enumerate(a)返回一个枚举对象
	该枚举对象包含了(0, 1)，(1, 2)和(2, 3)三个元组

	enumerate()函数有两个参数：iterable和start。
	iterable是要枚举的可迭代对象
	start是索引的起始值，默认为0。
	例如，enumerate(a, 1)将从1开始枚举列表a中的元素。
	可以用于循环遍历去枚举序列类型的元素以及它们的索引。
```python
a = ['apple', 'banana', 'orange']
for i, x in enumerate(a):
    print(i, x)
```

```
0 apple
1 banana
2 orange
```

#### 迭代器的定义
	迭代器是一种惰性计算的对象，在需要时才生成下一个元素而非一次性生成所有元素。
	这样可以节省内存和提高效率
	但是如果想把结果保存下来或者重复使用，就需要把迭代器转换成列表或者其他容器类型

#### 迭代--列表推导式(newlist)
	列表推导式在逻辑上等价于循环语句,只是形式上更加简洁
	列表推导式的一般形式是：
	new_list = [expression for member in iterator ]
	expression是对每个元素执行的表达式
	可以是元素本身,也可以是对元素进行计算或调用方法的表达式
	iterator是迭代器,这个迭代器后面还可以加上if条件来限定迭代器中的筛选

``` python
# 如果想要创建一个包含1到10的平方数的列表，可以使用以下列表推导式：
squares = [i * i for i in range(1, 11)]
```

	# 这里，expression是i * i，表示对每个元素求平方。
	# member是i，表示range(1, 11)中的每个值。
	# iterator是range(1, 11)，表示一个可迭代对象。
```python
# 创建一个包含1到10的偶数的列表：
even1 = [i for i in range(1, 11) if i % 2 == 0]

# 上下两个是等价的
even2 = []
for i in range(1,11):
	if i % 2 == 0:
		even2.append(i)
```
	# 这里，expression是i，表示不进行操作,迭代器仅仅只有元素本身。
	# member是i，表示range(1, 11)中的每个值。
	# iterator是range(1, 11)，表示一个可迭代对象。
	# 还有一个可选的if子句，用于过滤出符合条件的元素
```python
# 写一个嵌套
list1 = [ [i,j] for i in [1,2,3] for j in [4,5,6]]
# 这里写一个[i,j]是要求返回一个这样的列表
# 而列表推导式又会再得到一个新列表,因此是一个嵌套着列表的新列表

# 上下两个是等价的
list2 = []
for i in [1,2,3]:
	for j in [4,5,6]:
		list2.append([i,j])

# 结果是[ [1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6] ]
```

```python
list1 = [ [i,j] for i in [1,2,3] if i!=1 for j in [1,2,3] if i==j ] 

list2 = []
for i in [1,2,3]:
	if i != 1:
		for j in [1,2,3]:
			if i == j:
				 list2.append([i,j])
# 结果是[ [2,2],[3,3] ]
```

```python
vec = [[1,2], [3,4]]

[col for row in vec for col in row]

#`[1, 2, 3, 4]`。
```

	 迭代 `vec` 的每个元素 `row`。
	对于每个 `row` 中的元素 `col`，将其添加到结果列表中。

	因此，我们可以按顺序执行表达式，并追踪结果列表的变化：
	1.  首先，我们迭代 `vec` 的第一个元素 `[1, 2]`。
	    -   对于第一个元素 `row = [1, 2]`，迭代其中的元素 `col`。
	        -   添加 `col = 1` 到结果列表：结果列表为 `[1]`。
	        -   添加 `col = 2` 到结果列表：结果列表为 `[1, 2]`。
	2.  接下来，我们迭代 `vec` 的第二个元素 `[3, 4]`。
	    -   对于第二个元素 `row = [3, 4]`，迭代其中的元素 `col`。
	        -   添加 `col = 3` 到结果列表：结果列表为 `[1, 2, 3]`。
	        -   添加 `col = 4` 到结果列表：结果列表为 `[1, 2, 3, 4]`。

```python
 vec = [[1,2], [3,4]
[[row[i] for row in vec] for i in range(len(vec[0]))]
```
	首先，`len(vec[0])` 返回 `vec[0]` 的长度，即 `2`。这是因为 `vec` 的第一个元素 `vec[0]` 是 `[1, 2]`，其包含两个元素。
	接下来，我们迭代 `range(len(vec[0]))`，也就是迭代范围为 `[0, 1]`。
	对于每个迭代的值 `i`，我们执行以下操作：
	    - 针对 `vec` 中的每个元素 `row`，我们访问 `row[i]`，也就是 `row` 在索引 `i` 处的元素。
	    - 我们将这个元素添加到一个内部列表中。
	最终，我们获得一个包含内部列表的列表，其中内部列表按照 `vec` 的列进行填充。
	
	现在，我们按顺序执行表达式，并追踪结果列表的变化：
	
	1.  对于迭代值 `i = 0`：
	    
	    -   对于 `vec` 中的第一个元素 `[1, 2]`，访问索引 `0`，即 `1`。
	    -   对于 `vec` 中的第二个元素 `[3, 4]`，访问索引 `0`，即 `3`。
	    -   我们得到一个内部列表 `[1, 3]`。
	2.  对于迭代值 `i = 1`：
	    
	    -   对于 `vec` 中的第一个元素 `[1, 2]`，访问索引 `1`，即 `2`。
	    -   对于 `vec` 中的第二个元素 `[3, 4]`，访问索引 `1`，即 `4`。
	    -   我们得到一个内部列表 `[2, 4]`。
	
	最终，我们获得一个包含两个内部列表的列表 `[[1, 3], [2, 4]]`。

#### 迭代--生成器推导式(generator)
	语法: gen = ( expression for member in iterator ) 
	标志是括号,区别于列表推导式的中括号
	不管如何使用,只能从前往后访问生成器的元素,且访问完之后,无法回头重新访问
	只能重新创建该生成器对象
```python
gen = (i**2 for i in range(10))
print(gen) # 结果会把该生成器对象所在地址敲出来
list1=list(gen) # 将生成器转换成列表后接收
print(list1) # 结果是[1,4,9,...,81]
list2=list(gen) # 此时生成器里已经被访问过了且遍历完了所有元素
print(list2) # 结果是[ ],即生成器内无元素了

gen=(i ** 2 for i in range(10))
for i in gen:
	print(i,end='') # 结果是 0  1  4  9  16  25  36  49  64  81  
print(list(gen)) # 遍历完成之后gen内已经没有元素生成了
```
	语法: gen.__next__()
	这是生成器的内置方法,可以进行逐一访问,直至遍历完成
	语法: next(迭代器,默认值)
	这是一个相关函数,可以实现相同的功能
	第二个参数是当迭代器中无元素时可以返回的默认值,不写默认为"StopIteration"异常
```python
gen = (i**2 for i in range(10))
gen.__next__() # 结果是1
gen.__next__() # 结果是4
next(gen) # 结果是9
```
	这里有一个判断是否为子列表的运算函数
	列表推导式`[elem in b for elem in a]`将返回一个布尔值列表，
	其中每个元素都是`a`中的元素是否在`b`中的布尔值。
	`all()`函数将检查布尔值列表中的所有元素是否都为`True`。
	如果是，则返回`True`，否则返回`False`。
```python
a = [1, 2, 3]
b = [0, 1, 2, 3, 4, 5]

if all(elem in b for elem in a):
    print("a is a sublist of b")
else:
    print("a is not a sublist of b")
```

#### 迭代--字典推导式(domain)
	语法: {键表达式:值表达式 for 变量 in 列表 if 条件}
	字典推导式是一种用来从一个数据序列构建一个新的字典的方法
	键表达式和值表达式是用来计算新字典的键和值的
	变量是用来遍历列表的
	条件是用来过滤列表的(可不写)
```python
dict1={'a':1,'b':2,'c'=3}
dict2={key:value for key,value in dict1.items()} 
print(dict2) # 结果仍然是{'a':1,'b':2,'c'=3}
dict1 is dict2 # False
```

#### 逻辑运算notandor和身份运算is/isnot和成员运算in/notin
	not：取反运算    and：与运算     or：或运算
	is / is not：比较是否为同一对象
	in / not in：测试某数据是否在某一序列或可迭代对象之中
```python 
dict1={'a':1,'b':2,'c':3}
'a' in dict1 # 结果是True
1 in dict1 # 结果是False 字典判断的是是否有"键"而非"值"
```
	
#### 内置的测试函数all(),any(),isinstance()
	语法: all(iterable)
	用于检测序列或者可迭代对象中的所有元素值是否都是非False的 (数学逻辑^)
	如果都True则返回True,否则返回False(全真才真,有假则假)
```python
all(['a','b','','c']) # False
all(('a','b',0,'c')) # False
all({'a','b','0','c'}) # True 字符0不算False,字符0的AsCII是48
```
	语法: any(iterable)
	用于检测序列或者可迭代对象中至少有一个元素值为True (数学逻辑V)
	如果有True则返回True,否则返回False(全假才假,有真则真)
```python
any({}) # False
any({1,2,'','3'}) # True
any({0,0,0}) # False
```
	语法: isinstance(obj,class_or_tuple) (?)
	用于检测obj是不是那个类型
```python
# 检查整数是否是 int 类型的实例
num = 10
print(isinstance(num, int))  # 输出: True

# 检查字符串是否是 str 类型的实例
text = "Hello, World!"
print(isinstance(text, str))  # 输出: True

# 检查列表是否是 list 或 object 类型的实例
my_list = [1, 2, 3]
print(isinstance(my_list, (list, object)))  # 输出: True

# 检查对象是否是自定义类 MyClass 的实例
class MyClass:
    pass

obj = MyClass()
print(isinstance(obj, MyClass))  # 输出: True

```

#### divmod() 取除数余数的函数(division modulus)
	函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)
	此时可以通过多变量赋值来接收元组里的这两个元素
```python
a,b=divmod(153,100) # a=153//100，b=153%100。所以，a的值是1，b的值是53。
divmod(7,2) # 结果是(3,1)
divmod(8,4) # 结果是(2,0)
```

#### 正则表达式(regular expression)
	通俗易懂地讲，正则表达式就是一种用来描述字符串特征的规则
	你可以用它来检查一个字符串是否符合你的要求,或者从一个字符串中提取出你想要的部分
	正则表达式是由普通字符和特殊字符组成的 
		普通字符是字母、数字、标点符号等
		特殊字符是有特殊含义的符号
		如 '*'表示重复 '.'表示任意字符 '\b'表示单词边界等。
	你可以用特殊字符来表示一些复杂的规则
		比如 [a-z]* 表示任意个小写字母
	    \d{3,5} 表示三到五个数字
	    [a-zA-Z0-9_]+@[\w-]+(.[\w-]+)+ 表示一个邮箱地址等
比如验证用户输入的格式是否正确，比如手机号、身份证号、邮箱等；或者从网页源码中提取出你感兴趣的信息，比如图片链接、新闻标题、评论内容等；或者对文本文件进行批量的查找、替换、删除等操作。正则表达式是一种通用的文本处理工具，你可以在很多编程语言和软件中使用它

#### 常见元字符
	元字符是正则表达式中有特殊含义的字符
	它们可以表示一些特定的字符类别、数量、位置、模式等。常用的元字符有以下几种：
```python
`.`  #表示任意一个字符，除了换行符和回车符。
`^`  #表示匹配以^后面的字符开头的字符串。
`$`  #表示匹配以$前面的字符结尾的字符串
`*`  #表示匹配*前面的子表达式0次或多次。 等价{0,}
`+`  #表示匹配+前面的子表达式1次或多次。 等价{1,}
`?`  #表示匹配?前面的子表达式0次或1次，或表示非贪婪模式。 等价{0,1}
`-`  #表示一个匹配范围
`{n,m}` #表示匹配{}前面的子表达式至少 n 次，最多 m 次。
`( )` #表示定义一个子表达式的开始和结束位置，或表示分组。
`[ ]` #表示定义一个字符集合，匹配其中任意一个字符。
`|` #表示逻辑或，匹配两边的子表达式之一。
`\` #表示转义字符，用来取消后面字符的特殊含义，或表示一些预定义的字符类别。
```
	 <字符集合>的元字符展示
```python
[abc] #匹配包含[]内任意一个字符,'[abc]rank'可以匹配'arank''brank'等
[^abc] #不匹配包含[]内任意一个字符,匹配其他,'[^abc]rank'可以匹配'drank'等
[a-z] #匹配指定范围a~z的任意字符,例如[A-Za-z]等等
[^a-z] #匹配指定范围之外的任意字符
```
	接着是<选择功能>的元字符展示,注意'|'的优先级很低,故常使用括号括起来
```python
(a|b)+c #匹配至少一个a或b,后面跟着c
```
	接着是一些<重复功能>的元字符展示
```python
X* 
#等价于x{0,},例如,'Su*'匹配'S'、'Su'、'Suu'、'Suuu'等
# Su* 这个正则表达式的意思是匹配以 S 开头，后面跟 0 个或多个 u 的字符串。
# *号代表前面的字符可以不出现，也可以出现一次或者多次
x+ 
#等价于x{1,},例如,'Su+'匹配'Su'、'Suu'、'Suuu'等,但不匹配'S' 
#Su+，但表示匹配以 S 开头，后面跟 1 个或多个 u 的字符串
x? 
#等价于 x{0,1},例如,'Su?'匹配'S'或'Su',其他一律不匹配 
x{m,n} 
#x至少重复 m 次,最多重复 n次,例如,'Su{1,3}'匹配'Su'、'Suu' 'Suuu' 
x{n} 
#x重复n次,例如,'Su{2}'匹 配'Suu',但不能匹配'Su' 
x{m,} 
#x至少重复m次,例如,'Su{1,}'匹配'Su','Suu'等,但不匹配'S' 
x\num 
# 引用分组(子模式)num 匹配 到的字符串,例如,'(x)(y)\2'
# 该表达式中的'\2'表示引用第二个分组'(y)',所 以匹配'xyy',但不匹配'xy','xyz'
```
	<子模式>的展示
```python
(ab)*c
#可以匹配'c','abc','ababc' 
#此时ab姑且视作一个整体参与正则表达式的运算
```
	<边界匹配>的展示
```python
^a 
#匹配以a开头的字符串
a$ 
#匹配以a结尾的字符串
\bx\b #匹配一个单词的边界，也就是单词和空格之间的位置
# 例如，\bcat\b可以匹配"cat"这个单词,因为左右都是非单词字元
# 但不会匹配"catch"或"category"中的"cat"。因为右边有单词字元
\Bx\B  #匹配非单词边界，也就是单词中间的位置，或者两个非单词字符之间的位置
# 例如，cat\B可以匹配"category"中的"cat"，因为右边
# 但不会匹配"cat"这个单词
\Ax #匹配字符串的开始位置
# 例如，\Acat可以匹配"catnip"中的"cat"，
# 但不会匹配"concatenate"中的"cat"。
x\Z #匹配字符串的结束位置，或者在换行符前的位置   
# 例如，cat\Z可以匹配"tomcat"中的"cat"
# 但不会匹配"catnip"中的"cat"。
```
#### 常用预定义字符集
	Python的正則表達式模塊re提供了一些字符類，用來匹配不同類型的字符。
	使用前别忘了用r来实现原始字符串的输出
```python
-   \n #表示一个换行符。
-   \t  #表示一个制表符。
-   \d #匹配任何十進制數字，相當於 [0-9]。
-   \D #匹配任何非數字字符，相當於 [^0-9]。
-   \s #匹配任何空白字符，相當於 [ \t\n\r\f\v]。
-   \S #匹配任何非空白字符，相當於 [^ \t\n\r\f\v]。
-   \w #匹配任何字母數字字符，相當於 [a-zA-Z0-9_]。
-   \W #匹配任何非字母數字字符，相當於 [^a-zA-Z0-9_]。
```
	舉例來說，如果我們想要匹配一個電話號碼
	它表示匹配三個數字，一個破折號，四個數字，一個破折號，四個數字。
```python
\d{3}-\d{4}-\d{4}
# 這個正則表達式可以匹配 123-4567-8901，
# 但不能匹配 12345678901 或 123-456-7890。
```

#### numpy库-array(数组)
	array和list的区别
	-   array是numpy库中的对象，而list是Python的内置数据类型。
	-   array中的元素都是同一类型，而list中的元素可以是不同类型。
	-   array支持高效的数学运算和矩阵运算，而list则不支持或者比较麻烦。
	-   array占用的内存空间比list小，因为array是连续的内存块，而list是指针。
	-   可以使用numpy.array()函数将列表转换为array对象
```python
arr = np.array([1, 2, 3])。
```
	array和c语言的数组区别
```python
# 导入numpy模块
import numpy as np

# 定义一个c语言的数组，需要确定大小
int c_array[5];
# 定义一个numpy的array，根据输入数据自动创建
np_array = np.array([1, 2, 3, 4, 5])

# 通过下标访问c语言的数组和numpy的array的元素
c_array[0] = 10 # 将c语言数组的第一个元素赋值为10
np_array[0] = 10 # 将numpy array的第一个元素赋值为10

# 通过切片访问numpy的array的元素,切下2,3两个元素并修改
np_array[1:3] = [20, 30] # 将numpy array的第二个第三个元素赋值为20和30

# 通过sizeof()函数获取c语言数组占用内存大小，单位为字节
int size = sizeof(c_array); # size等于20
![[Pasted image 20231217211017.png]]
# 通过nbytes属性获取numpy array占用内存大小，单位为字节
size = np_array.nbytes # size等于20

# 对c语言数组和numpy array进行加法运算
int c_sum = c_array[0] + c_array[1]; # c_sum等于30
np_sum = np_array[0] + np_array[1]; # np_sum等于30

```

#### copy库-深浅复制
	copy模块提供了浅层(shallow)和深层(deep)复制操作，用于复制对象。
	浅层复制操作只复制了对象的引用，而不是对象本身。
	深层复制操作会复制对象本身，而不是对象的引用。
	好的，下面是一个简单的例子，展示了如何使用copy模块的浅层复制操作。
```python
import copy

list1 = [1, 2, [3, 4]]
list2 = copy.copy(list1)

print("list1: ", list1)
print("list2: ", list2)

list2[2][0] = 5

print("list1: ", list1)
print("list2: ", list2)
```
	输出结果：
```python
list1:  [1, 2, [3, 4]]
list2:  [1, 2, [3, 4]]
list1:  [1, 2, [5, 4]]
list2:  [1, 2, [5, 4]]
```
	深层复制操作会复制对象本身，而不是对象的引用。
	因此，当你修改了复制后的对象时，原对象不会受到影响。
	下面是一个简单的例子，展示了如何使用copy模块的深层复制操作。
```python
import copy

list1 = [1, 2, [3, 4]]
list2 = copy.deepcopy(list1)

print("list1: ", list1)
print("list2: ", list2)

list2[2][0] = 5

print("list1: ", list1)
print("list2: ", list2)
```
	输出结果：
```python
list1:  [1, 2, [3, 4]]
list2:  [1, 2, [3, 4]]
list1:  [1, 2, [3, 4]]
list2:  [1, 2, [5, 4]]
```

#### turtle库-绘画
	turtle库的方法：

```python
turtle.forward(distance)：向前移动指定距离
turtle.backward(distance)：向后移动指定距离
turtle.right(angle)：向右旋转指定角度
turtle.left(angle)：向左旋转指定角度
turtle.penup()：抬起画笔，不绘制图形
turtle.pendown()：放下画笔，绘制图形
turtle.pencolor(color)：设置画笔颜色
turtle.fillcolor(color)：设置填充颜色
turtle.begin_fill()：开始填充
turtle.end_fill()：结束填充
turtle.circle(radius)：绘制圆形
turtle.dot(size)：绘制点
turtle.goto(x, y)：移动到指定坐标
turtle.setx(x)：设置x坐标
turtle.sety(y)：设置y坐标
turtle.setheading(angle)：设置当前方向
turtle.speed(speed)：设置绘制速度
turtle.setpos(x,y)：将画笔移动到坐标为(x,y)的位置。
turtle.setx(x)：将画笔移动到x轴坐标为x的位置。
turtle.sety(y)：将画笔移动到y轴坐标为y的位置。
turtle.setheading(angle)：将画笔的方向设置为angle度。
turtle.home()：将画笔移动到原点位置。
turtle.dot(size,color)：在当前位置绘制一个指定大小和颜色的圆点。
turtle.undo()：撤销上一次的操作。
turtle.clear()：清空画布。
turtle.reset()：重置画布。
turtle.onkey(func()," "):将函数与键盘上的按键绑定。当按下该键时，将调用该函数。
turtle.listen():它可以确保海龟窗口处于桌面的焦点中，这样就可以监听按键事件
turtle.ontimer(func(),t):用于安装一个定时器，在t毫秒后调用fun,单位是毫秒。
```
	好的，以下是一个使用turtle库绘制背景和游戏标题的示例代码块，注释已经写好了：
	
```python

import turtle

# 设置画布的背景颜色
turtle.bgcolor("black")

# 设置画布的大小
turtle.setup(800, 600)

# 绘制游戏标题
turtle.penup()
turtle.goto(-200, 200)
turtle.write("游戏标题", font=("Arial", 16, "normal"))
turtle.pendown()

# 设置画笔的形状
turtle.shape("turtle")

# 设置画笔的颜色
turtle.color("red")

# 绘制图形
turtle.begin_fill()
turtle.circle(50)
turtle.end_fill()

# 监听鼠标事件
def click(x, y):
    turtle.goto(x, y)

turtle.onclick(click)

# 监听键盘事件
def up():
    turtle.forward(10)

turtle.onkey(up, "Up")

# 开始监听事件
turtle.listen()

# 开始主循环
turtle.mainloop()

turtle.bgpic()来设置画布的背景图片，
turtle.bgpic("bg.gif")

turtle.write()`来绘制游戏标题，如turtle.write("游戏标题", font=("Arial", 16, "normal"))
turtle.penup()`和`turtle.goto(x, y)`来移动画笔到指定位置，然后使用`turtle.pendown()`来绘制图形。
turtle.shape()`来设置画笔的形状，如`turtle.shape("turtle")`。
turtle.color()`来设置画笔的颜色，如`turtle.color("red")`。
turtle.begin_fill()`和`turtle.circle(50)`绘制一个圆形并填充。
urtle.onclick()来监听鼠标事件，如`turtle.onclick(click)`来监听鼠标单击事件。
turtle.onkey()来监听键盘事件，如`turtle.onkey(up, "Up")`来监听键盘上键按下事件。
turtle.listen()`来开始监听事件，如`turtle.listen()`。
turtle.mainloop()`来开始主循环，如`turtle.mainloop()`。
turtle.exitonclick()`来退出程序，如`turtle.exitonclick()`。
turtle.tracer()`来控制动画的速度，如turtle.tracer(0, 0)`来关闭动画的速度。、
turtle.update()`来更新画布，如`turtle.update()`。
turtle.delay()`来设置动画的延迟，如`turtle.delay(0)`来关闭动画的延迟。
turtle.clear()`来清除画布，如`turtle.clear()`。
turtle.reset()`来重置画布，如`turtle.reset()`。
turtle.undo()`来撤销上一步操作，如`turtle.undo()`
turtle.speed()`来设置画笔的速度，如`turtle.speed(0)`来设置画笔的速度为最快。
turtle.screensize()`来设置画布的大小，如`turtle.screensize(800, 600)`来设置画布的大小为800x600。
turtle.setworldcoordinates(-100, -100, 100, 100)`来设置世界坐标系的范围为(-100, -100)到(100, 100)。
turtle.setx(0)`和`turtle.sety(0)`来设置画笔的坐标为(0, 0)。
turtle.stamp()`来复制画笔的形状，如`turtle.stamp()`来复制画笔的形状
turtle.dot()`来绘制一个点，
```
#### threading库
	当一个线程调用另一个线程的join()方法时，调用线程将被阻塞，直到被调用的线程执行完毕
```python
import threading

def my_function():
  print("Start")
  # Do something
  print("End")

threads = []
for i in range(5):
  t = threading.Thread(target=my_function)
  threads.append(t)
  t.start()

# Wait for all threads to complete
for t in threads:
  t.join()

print("All threads are done!")
```


#### 使用pip安装Python第三方扩展库 
>检查是否正确配置好Python和pip运行环境
```cmd
python --version
pip --version
```
>然後，您可以使用以下命令來安裝一個包：
>其中package_name是您想要安裝的包的名字，例如numpy或pandas。
```cmd
pip install package_name
```
>如果您想要更新一個已經安裝的包，您可以使用以下命令：
```cmd
pip install --upgrade package_name
```
>如果您想要卸載一個已經安裝的包，您可以使用以下命令：
```cmd
pip uninstall package_name
```
>如果您想要查看已經安裝的包的列表，您可以使用以下命令：
```cmd
pip list
```
>如果您想要查看某個包的詳細信息，例如版本、依賴和位置，您可以使用以下命令：
```cmd
pip show package_name
```
>升级pip
```cmd
pip install -U pip
```

