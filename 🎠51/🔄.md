
## 开发板以及c51基础编程
- 芯片四周是引脚，左下角的小圆点表示 1 脚，然后从 1 脚起按照逆时针的顺序排列 （所有芯片的引脚顺序都是逆时针排列的）。
- 开发板中把芯片的引脚引出来，连接到各种 传感器上，然后在 STM32 上编程（实际就是通过程序控制这些引脚输出高电平或者低电平） 来控制各种传感器工作。

#### 进制转换

| 十进制 | 二进制    | 八进制 | 十六进制 |
| ------ | --------- | ------ | -------- |
| 0      | 0000 0000 | 0      | 0        |
| 1      | 0000 0001 | 1      | 1        |
| 2      | 0000 0010 | 2      | 2        |
| 3      | 0000 0011 | 3      | 3        |
| 4      | 0000 0100 | 4      | 4        |
| 5      | 0000 0101 | 5      | 5        |
| 6      | 0000 0110 | 6      | 6        |
| 7      | 0000 0111 | 7      | 7        |
| 8      | 0000 1000 | 10     | 8        |
| 9      | 0000 1001 | 11     | 9        |
| 10     | 0000 1010 | 12     | A        |
| 11     | 0000 1011 | 13     | B        |
| 12     | 0000 1100 | 14     | C        |
| 13     | 0000 1101 | 15     | D        |
| 14     | 0000 1110 | 16     | E        |
| 15     | 0000 1111 | 17     | F         |

 #### 按位运算
`&=` 操作符（按位与赋值）：

- `&=` 用于将变量的每个位与右侧的值进行按位与操作，并将结果存储回原始变量中。
- 这意味着只有原始变量和右侧值的对应位都为1时，结果位才为1；否则，结果位为0。
- `&=` 常用于清除特定位上的标志位，将一个或多个特定的位设置为0。
```c
int x = 0b11001100;  // 二进制表示为 11001100
x &= 0b11110000;     // 执行按位与操作
// 结果：x 现在等于 0b11000000
```

`|=` 操作符（按位或赋值）：

- `|=` 用于将变量的每个位与右侧的值进行按位或操作，并将结果存储回原始变量中。
- 这意味着只要原始变量或右侧值的对应位之一为1，结果位就为1；否则，结果位为0。
- `|=` 常用于设置特定位上的标志位，将一个或多个特定的位设置为1。

```c
int y = 0b11001100;  // 二进制表示为 11001100
y |= 0b00110011;     // 执行按位或操作
// 结果：y 现在等于 0b11111111
```

#### 代码示范
-  一个典型的C51程序由包含头文件、位定义、主函数等代码构成，以点亮LED1的C51程序为例，其代码如下。
	- 头文件是包含了函数声明、宏定义等内容的文件，在C51中也常常包含特殊功能寄存器定义。
	- 包含头文件有两种方式：尖括号包含（如#include <reg52.h>）和双引号包含（如#include "reg52.h"）
	- 在C51程序中，主函数是最核心的部分，是程序的唯一入口。一个C51程序有且仅有一个主函数。
```c
#include <reg52.h>        //包含头文件，表示该单片机为8052单片机

sbit LED1 = P2^4;         //表示LED1连接至P2.4引脚

void main()               //主函数
{
	while(1)              //重复这些工作
	{   
		LED1 = 0;         //将LED1所在的引脚设为低电平
	}
}
```

#### c语言关键字
|  |  | | |  | | |  | |     |
| ----------- | ------ | -------- | ------ | -------- | -------- | -------- | ------ | 
| `auto `       | `break`  | `case`     |` char`   | `const  `  | `continue` | `default`  | `do`     |   
| `int `        | `long`   |` register `|` return `| `short`    | `signed `  | `sizeof`   |` static` |      
| `struct  `    | `switch` | `typedef`  | `union ` | `unsigned` |` void `    | `volatile` | `if `    | 

#### c51扩展关键字
|             |          |         |               |             |           |         |         |
| ----------- | -------- | ------- | ------------- | ----------- | --------- | ------- | ------- |
| `_at_ `     | ` alien` | `bdata` | `bit `        | `code`      | `compact` | `data ` | `idata` |
| `interrupt` | `large`  | `pdata` | ` _priorty_ ` | `reentrant` | `sbit`    | `sfr`   | `sfr16` |
| `small`     | `_task_` | `using` | `xdata`              |             |           |         |         |

#### 基本数据类型
- C51程序中基本的数据类型主要有字符型、整型、长整型以及浮点型，其占用空间以及表示范围如下表所示。
- 注意，在不同的平台下，C语言数据类型的占用空间可能会不一致，此表格中的数据仅适用于C51

| 数据类型            | 占用字节 | 范围                   |
| ------------------- | -------- | ---------------------- |
| `unsigned char`     | 1        | 0~255                  |
| `signed char`       | 1        | -128~127               |
| `unsigned int`      | 2        | 0~65535                |
| `signed int`        | 2        | -32768~32767           |
| `unsigned long int` | 4        | 0~($2^{32}$-1)         |
| `signed long int `  | 4        | -$2^{31}$~($2^{31}$-1) |
| `float `              | 4        | ±(1.175494E)-38 ~ ±(3.402823E)+38                       |

-  在实际编程中，遵循尽量减少占用存储空间的原则。
	- 能够使用char类型表示一个数据，则不采用int类型，以节省存储空间，提高单片机运行效率。
	- 另外，在不需要表示负数的场合，也应尽量使用无符号型变量。

- 字符型 `char`
	- 字符型常用于存放一个字符或较小的整数数字。在51单片机中，字符是以ASCII码的形式存储的。

- 整形与长整型 `int long`
	- 整型一般存放整数数字，长整型通常存放较大的整数数字。

- 浮点型 `float`
	- 一般用于存放带小数点的数字。
	- 在C语言中还有double类型表示双精度的浮点型数据
	- 但在C51中，float类型与double类型精度一致，均为单精度浮点型。

- 位类型` bit`
	- 用于定义一个二进制变量，其值为0或1，例如将a定义为位类型的代码如下。
```c
bit a = 1;
```

- 位定义 `sbit`
	- 前文提到了位寻址的概念。用于定义寄存器的可寻址位，格式为 `sbit 名称 = 寄存器位地址;`
	- 以连接至 `P2.4` 引脚（位地址为 `0xA4` ）的 `LED1` 为例，使用 `sbit` 定义 `LED1` 的代码如下。
```c
sbit LED1 = 0xA4; //注意，只有支持位寻址的位，才可以用sbit关键字进行位定义。
```

- 特殊功能寄存器定义 `sfr`
	- 用于定义一个特殊功能寄存器，格式为 `sfr 名称 = 特殊功能寄存器地址;`
	- 以 `P2` 特殊功能寄存器为例，使用` sfr `定义 `P2` 的代码如下。
```c
sfr P2 = 0xA0;
```

#### 电阻读数
- 最后一位数是几就添几个零
```
102 = 10 00 = 1k
473 = 47 000 = 47k
1001 = 100 0 = 1k
```

![image.png](https://s2.loli.net/2023/08/05/bF3CHeX82DStglM.png)

#### LED工作原理
-   以LED1为例，当P2.4引脚为低电平( 0 )时，LED两侧产生电压差，LED1点亮。反之，当P2.4引脚为高电平 (1) 时，LED1熄灭
-   字节地址用于访问整个寄存器的数据。
-   位地址用于访问寄存器中每个比特的数据，用于位级别的控制和操作。
-   注意:
	- 只有可位寻址的寄存器才能使用 `sbit` 进行寻址, 可以进行位寻址的寄存器字节地址以 `0` 和 `8` 结尾
	- 否则就只能使用按字节控制
![image.png](https://s2.loli.net/2023/08/05/ylFcWGapf3i4eYt.png)


#### 按字节控制
- 必须使用 `sfr` 关键字定义特殊功能寄存器
```c
sfr P2 = 0xA0;  //定义特殊功能寄存器地址,其实只要包含了头文件<reg51.h>,就不用去定义P2,可以直接对其进行操作

P2 = 0xFF; // 设置P2端口全部为高电平（1）
P2 = 0x00; // 设置P2端口全部为低电平（0）

P2 = 0xAF; 
```

- `P2`是一个特殊功能寄存器（SFR），用于控制端口P2的输入输出。赋值 `P2=0xAF` 将在端口P2上设置特定的输出状态。
- 具体来说，`P2=0xAF` 会将P2的每个位设置为下面的状态 
```
P2^7 = 1
P2^6 = 0  //第六位设置为低电平
P2^5 = 1
P2^4 = 0  //第四位设置为低电平
P2^3 = 1
P2^2 = 1
P2^1 = 1
P2^0 = 1
```

#### 按位操作

- 通过 `sbit` 对 [ 可以进行位寻址的寄存器中的某一位 ] 进行赋值

![gh](https://raw.githubusercontent.com/odddouglas/image/main/upgitimage.png)

```c
sbit LED1 = 0xA4; //位定义LED1,这是通过特殊功能寄存器的可寻址的位数,

sbit LED1 = P2^4; //位定义LED1,这个比较常用 

LED1 = 0; // 设置成低电平(0) ,此时也就是点亮了LED1
```




## 独立按键原理
- 按键未按下时，此时出现断路, 电流流入引脚, 输入芯片引脚( P3.2, P3.3 , P3.4 )的电平为高电平 ( 1 )
- 按键按下时，电流流过KEY1, 此时出现短路, 输入芯片引脚上的电平为低电平 ( 0 )
![image.png](https://s2.loli.net/2023/08/05/iN6pXne5wHRlOUF.png)

#### 按键软件消抖

- 按键被按下的期间, 被判定的时间不定, 它有一个前沿抖动, 也就是前摇, 以确保按键不是被误触 ,
- 我们需要在按键疑似被按下的时候进行延迟处理,最后再次检测是否真的被按下
```c
sbit KEY1 = P3^2; //位定义

if( 0 == KEY1 )
{
	DelayNms(50); //等待约50ms后,再次检测,
	if( 0 == KEY1 )
	{
		//确定按键被按下, 执行触发事件
	}
	while( 0 == KEY1 ); //等待弹起
} 
```

#### 无定时器的简易[单击响应]操作
-  一次按键,此时灯亮并持续亮起,再一次按键将会熄灭
```c

while(1)
{
    if (0 == KEY1) //第一次检测到KEY1按键被按下
    {
      DelayNms(50);  //等待约50ms后再次检测按键是否被按下，消除按键抖动带来的影响
      if (0 == KEY1) //第二次检测到KEY1按键被按下
      {
        LED1 = ~LED1; //对LED1状态取反，改变LED1的亮灭状态
        while (0 == KEY1); //等待按键弹起
      }
    }
}
```

#### 无定时器的简易[即按即响应]操作
-  一次按键,此时灯亮,一直按一直亮, 按键弹起之后熄灭
```c
while(1)
{
    if (0 == KEY2) //第一次检测到KEY2按键被按下
    {
      DelayNms(50);  //等待约80ms后再次检测按键是否被按下，消除按键抖动带来的影响
      if (0 == KEY2) //第二次检测到KEY2按键被按下
      {
        LED2 = ~LED2; //对LED2状态取反，改变LED2的亮灭状态
        while (0 == KEY2); //等待按键弹起
        DelayNms(500); 
	    LED2 = ~LED2; //等待之后, LED2亮灭状态再次取反
      }
    }
}
```

## 数码管
- 常见的数码管通常有7个LED组成，被称为7段数码管，每个LED代表数码管的一个段。这些段按照特定的编码方式来表示不同的数字或字母。
- 在共阴极数码管中，所有LED的阴极（负极）连接在一起，而各个LED的阳极（正极）分别连接到各自的引脚。
- 在共阳极数码管中，所有LED的阳极（正极）连接在一起，而各个LED的阴极（负极）分别连接到各自的引脚。

- 下图就是一个共阳极数码管
![image.png](https://s2.loli.net/2023/08/07/HT1rL6j43tbmMqg.png)

- 位选引脚控制
```c

//位定义各个数码管

sbit SegmentG1 = P2 ^ 3; //定义数码管1
sbit SegmentG2 = P2 ^ 2; //定义数码管2
sbit SegmentG3 = P2 ^ 1; //定义数码管3
sbit SegmentG4 = P2 ^ 0; //定义数码管4

// 点亮了数码管1 其余关闭, 此时数码管1的所有段亮起,呈现 "8" 字样

SegmentG1 = 0;           //打开数码管1
SegmentG2 = 1;           //关闭数码管2
SegmentG3 = 1;           //关闭数码管3
SegmentG4 = 1;           //关闭数码管4

```
-  段选引脚控制
```c
P0 = 0x41;                 //数码管1显示为数字6
// 数字“6”的段码为01000001，转换为十六进制即0x41，因此将P0寄存器赋值为0x41
```
- 静态显示 就是(位选+段选), 也就是[位选]先开启哪一位数码管, 接着再[段选]开启该位数码管的哪些段, 从而呈现字样
- 以下是共阳极的LED字样

| 8位字段(a,b,c,d,e,f,g,dp) | 显示字符 |
| ------------------------- | -------- |
| 0000 0011（0x03）         | 0        |
| 1001 1111（0x9F）         | 1        |
| 0010 0101（0x25）         | 2        |
| 0000 1101（0x0D）         | 3        |
| 1001 1001（0x99）         | 4        |
| 0100 1001（0x49）         | 5        |
| 0100 0001（0x41）         | 6        |
| 0001 1111（0x1F）         | 7        |
| 0000 0001（0x01）         | 8        |
| 0000 1001（0x09）         | 9        |
| 0001 0001（0x11）         | A        |
| 1100 0001（0xC1）         | b        |
| 0110 0011（0x63）         | C        |
| 1000 0101（0x85）         | d        |
| 0110 0001（0x61）         | E        |
| 0111 0001（0x71）         | F         |

#### 数码管数字字母段码展示
```c
unsigned char leddata[]=
{ //共阳极
    0xC0,  //"0"
    0xF9,  //"1"
	0xA4,  //"2"
	0xB0,  //"3"
	0x99,  //"4"
	0x92,  //"5"
	0x82,  //"6"
	0xF8,  //"7"
	0x80,  //"8"
	0x90,  //"9"
	0x88,  //"A"
	0x83,  //"B"
	0xC6,  //"C"
	0xA1,  //"D"
	0x86,  //"E"
	0x8E,  //"F"
	0x89,  //"H"
	0xC7,  //"L"
	0xC8,  //"n"
	0xC1,  //"u"
	0x8C,  //"P"
	0xA3,  //"o"
	0xBF,  //"-"
	0xFF  //熄灭
	};

unsigned char leddata[]=
{ //共阴极
	0x3F,  //"0"
	0x06,  //"1"
	0x5B,  //"2"
	0x4F,  //"3"
	0x66,  //"4"
	0x6D,  //"5"
	0x7D,  //"6"
	0x07,  //"7"
	0x7F,  //"8"
	0x6F,  //"9"
	0x77,  //"A"
	0x7C,  //"B"
	0x39,  //"C"
	0x5E,  //"D"
	0x79,  //"E"
	0x71,  //"F"
	0x76,  //"H"
	0x38,  //"L"
	0x37,  //"n"
	0x3E,  //"u"
	0x73,  //"P"
	0x5C,  //"o"
	0x40,  //"-"
	0x00  //熄灭
};

```

#### 数码管动态显示( 以四位数码管为例 )
- 首先，如果轮流点亮每一位数码管，并在数码管熄灭与点亮之间的间隔中不断切换显示的数字
- 如果将切换的间隔不断缩小，每位数码管的点亮与熄灭之间的时间间隔缩短至5ms，
- 由于人的视觉暂留现象及发光二极体的余辉效应，尽管实际上各位数码管并非同时点亮，但只要切换的速度足够快，即可实现同时出现的效果。
![image.png](https://s2.loli.net/2023/08/07/VzrUo51sRnWYfbH.png)  ![image.png](https://s2.loli.net/2023/08/07/YqDlsoB9xUCAE5Z.png)
```c
while (1)
  {
    P1 = arrNumber[1]; //数码管1显示为数字1
    SegmentG1 = 0;       //打开数码管1
    DelayNms(5);         //延时5ms
    SegmentG1 = 1;       //关闭数码管1
    
    P1 = arrNumber[2]; //数码管2显示为数字2
    SegmentG2 = 0;       //打开数码管2
    DelayNms(5);         //延时5ms
    SegmentG2 = 1;       //关闭数码管2
  
    P1 = arrNumber[3]; //数码管3显示为数字3
    SegmentG3 = 0;       //打开数码管3
    DelayNms(5);         //延时5ms
    SegmentG3 = 1;       //关闭数码管3
   
    P1 = arrNumber[4]; //数码管4显示为数字4
    SegmentG4 = 0;       //打开数码管4
    DelayNms(5);         //延时5ms
    SegmentG4 = 1;       //关闭数码管4
  }
```

#### PWM控制LED亮度原理

PWM代表脉冲宽度调制（Pulse Width Modulation），。PWM通过控制脉冲信号的宽度来调节电压或电流，以实现对电子设备的精确控制。

1.  **调节占空比：** 占空比是指高电平时间与周期时间的比值。调整占空比可以改变信号的平均电平值。
	1. 占空比越大，平均电平值越高，LED亮度越高；
	2. 占空比越小，平均电平值越低，LED亮度越暗。
2.  **人眼暂时特性：** 由于人眼的暂时特性，对于高频率的PWM信号，人眼会认为LED的亮度是稳定的，而实际上LED在快速开关，改变亮度。

$$占空比D=\frac{t_H}{T}×100\%$$

- 使用一个比例指针,来控制占空比 , 注意有另一个默认的定时指针, 根据设定好的速度进行遍历,
- 使低于该比例指针的部分呈现低电平, 高于该比例指针的部分呈现高电平,从而实现呼吸灯
- 还可以调节周期长度, 来控制呼吸灯的速度
![[Pasted image 20230915001133.png]]
## 中断
- 中断就是CPU在处理某件事的时候,收到一个紧急请求, CPU暂停当前时间转而处理紧急时间 , 再返回来继续处理之前事件的过程
- `89C51`系列单片机提供了8个中断请求源,

#### 中断框架

![[Pasted image 20230810125136.png]]


| 中断源                       | 中断源名称               | 中断方式      | 中断请求标志位   | 中断源允许控制位 | 总中断允许控制位 | 中断号 |
| ---------------------------- | ------------------------ | ------------- | ---------------- | ---------------- | ---------------- | ------ |
| P3.2引脚的电平/脉冲状态      | INT0  (外部中断0)        | IT0 (TCON[0]) | IE0    (TCON[1]) | EX0 (IE[0])      | EA (IE[7])       |  0      |
| 定时/计时器0的溢出标志位状态 | T0  (定时器0)            | 溢出          | TF0 (TCON[5])    | ET0 (IE[1])      | EA (IE[7])       |     1   |
| P3.3引脚的电平/脉冲状态      | INT1  (外部中断1)        | IT1 (TCON[2]) | IE1    (TCON[3]) | EX1 (IE[2])      | EA (IE[7])       |    2    |
| 定时/计时器1的溢出标志位状态 | T1 (定时器1)             | 溢出          | TF1    (TCON[7]) | ET1 (IE[3])      | EA (IE[7])       |       3 |
| 串口数据缓冲器的工作状态     | TX/RX (串口(发送和接收)) | 接收/发送     | TI,RI            | ES               | EA  (IE[7])      | 4       |

![[Pasted image 20230810155109.png]]


#### 中断优先级

- 如果单片机正在处理一个中断程序，此时又有优先级更高的中断请求，单片机会暂停当前的中断程序，转而处理新的中断程序。
- 待新中断处理完毕后，再继续处理之前的中断程序。这个过程称为中断嵌套，最多可以实现两级中断服务程序嵌套。
![[Pasted image 20230810165010.png]]

#### 中断规则
1. 低优先级能够被高优先级中断，而高优先级不能被低优先级中断。
2. 当中断得到响应后，不会再被它的同级中断源所中断。
3. 如果不对中断优先级进行设置，则默认所有中断的优先级均为最低（优先级0），不发生中断嵌套

#### 中断查询

- 在同一优先级中，如果有多个同一优先级的中断同时触发，则CPU的响应顺序取决于内部硬件电路形成的查询次序, 注意,默认的时候, 所有中断的优先级均为最低, 此时也就是按照中断查询的次序

| 中断号 | 中断源         |
| ------ | -------------- |
| 0      | 外部中断0      |
| 1      | 定时器/计数器0 |
| 2      | 外部中断1      |
| 3      | 定时器/计数器1 |
| 4      | 串口中断       |
| 5      | 定时器/计数器2 |
| 6      | 外部中断2      |
| 7      | 外部中断3      |

-  **软件查询** 是指对中断使能位 `IE( interrupt enable )` 进行检测看是否满足中断条件
```c
if ( 1 == IE0) //
{
	...// 中断处理
	IE0 = =0 ;// 对外部中断0请求标志位清零
}
```

-  **硬件查询** 的响应过程由硬件完成。通常情况下，使用中断系统时都会采用硬件查询法，只有这样才能够体现出中断系统实时性强、效率高的优势。- 满足以下条件时，CPU将会对中断做出响应。
	（1）中断源发出中断请求，并且外部中断请求标志位为“1”。
	（2）中断源允许位为“1”。
	（3）总中断允许位为“1”。

#### 中断处理函数

- 在编写中断服务函数时，应遵循以下规则。
（1）只能由CPU处理中断时调用，不能在代码中直接调用。
（2）不能进行参数传递，若在中断服务函数中包含参数声明将导致程序编译出错。
（3）不能含有返回值，因此需要将中断服务函数类型定义为void类型

	语法: 函数类型 函数名() interrupt 中断号

```c
IT0 = 0; //或者IT0 = 1 ; 设置外部中断的触发方式是低电平还是高电平
EX0 = 0; //开 [外部中断0] 的中断允许位
EA = 1; //开 [总中断] 开关

void INT0() interrupt 0
{
	//这里是一个中断服务函数
}
```

## 定时器/计数器 框架
![[Pasted image 20230811141612.png]]

|GATE|INTx|TRx|定时器/计数器运行信号|
|---|---|---|---|
|0|1/0|1|运行（1）|
|0|1/0|0|不运行（0）|
|1|1|1|运行（1）|
|1|1|0|不运行（0）|
|1|0|1/0|不运行（0）|
#### 配置定时器

-   在这个情况下，两种方式都会达到相同的目标。按位操作主要用于在修改特定位时保留其他位不变，而直接赋值则更适用于在设置整个寄存器值时。在你的代码中，你可以选择使用更简洁的方式直接赋值。
```c
//使用位操作符
TMOD |= 0x01; // 设置为模式1
TMOD &= 0x0F; // 清除低4位的前三位，保留最后一位


//直接赋值：
TMOD = 0x01; // 设置为模式1，覆盖整个寄存器的值

// 工作方式2
TMOD = 0x02;  //设置 定时器0 工作方式2(8位自动重装)
TH0  = 0x9C;  //设置 定时器0 重装值
TL0  = 0x9C;  //设置 定时器0 计数初值，定时时间(256-156=100μs)
TR0  = 1;     //打开 定时器0
```

#### 定时器初值设置以及溢出原理

- 利用定时器直接进行1s延时是无法实现的，但是可以将定时中断和软件计数联合起来增加演示长度，即利用定时中断进行中断次数统计
- `1s` 延时可以视为20次50ms定时中断的累计延时量, 若采用`12MHz`频率定时模式 1 , 此时计数初值为 -5000
$$初值计算: 2^n-x  \quad(n为定时器/计数器的长度,x时需要计数的值)$$
- `n`一般是高八位加第八位也就是`16`位, 此时就是`FFFF`也就是`65535`,  $2^{16}$ 这个就是`65536`, 但是注意有些工作模式比如`MODE2`就是`8`位, 此时 $2^{8}$ 就是`256` 
例如使用定时器/计时器0在工作模式1下定时1ms( 计数值为1000(μs) )后溢出

```c
TMOD=0x01; //配置定时器

TH0=0xFC;  //设置高8位初值
TL0=0x18;  //设置低8位初值

//FC18 转换成十进制就是 64536 (也就是65536 - 1000) 

TR0=1; //启动定时器0
```



#### 结合定时器的 [短按长按响应]

用户基本操作定义：  
    1。短按操作：按键按下，按下时间<1s，属于一次短按操作  
    2。长按操作：按键按下，按下时间>1s，属于一次长按操作  
  
在正常0.5s内无按键操作为启始按键扫描条件下，扫描按键将产生以下3种按键事件：  
    1。长按事件：任何1次出现的长按操作都属于长按事件  
    2。单击事件：1次短按操作后，间隔0.5内没有短按操作  
    3。双击事件：2次短按操作间隔时间<0.5s，则2次短按操作为1次双击事件，且2次短按都取消  
  
特别操作情况定义：  
    1。短按操作和长按操作间隔<0.5s，以及，长按操作和短按操作间隔<0.5s，均不产生双击事件  
    2。连续n次（n为奇数）短按操作，且间隔均<0.5s，产生(n-1)/2次双击事件+1次单击事件  
    3。连续n次（n为偶数）短按操作，且间隔均<0.5s，产生n/2次双击事件
```c

```

## 串口通信

#### 通信协议(串行并行)

并行通信的各个位同时传输，每一位数据都需要一条传输线

- 在数码管显示实例中，数码管与单片机之间的通信，就利用了P0.0~P0.7共8个I/O引脚同时传输段码数据。并行通信的优点是传输速度较快，适合短距离传输。但是，并行通信需要占用大量的I/O引脚，成本较高。
![[Pasted image 20230912192836.png]]

- 串行通信将数据分成位的形式，在一条传输线上逐个传输，只需要两条数据线并接入公共GND即可实现双向传输。其中，同步串行通信需要时钟线，而异步串行通信不需要时钟线。串行通信是单片机系统中最为广泛采用的通信方式，它仅占用少量的I/O引脚，有利于降低成本，但缺点是传输速度较慢。
![[Pasted image 20230912192854.png]]

#### 同步异步以及单双工

- ==单工（Simplex）:== 
	- 只有一方能接受或发送信息，不能实现反向传输
- ==半双工（H-Duplex）: ==
	- 允许数据在两个方向上传输，但是在同一时间，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信，在同一时间只可以有一方接受或发送信息
- ==全双工（Duplex） :==
	- 允许数据同时在两个方向上传输，在同一时间可以同时接受和发送信息，实现双向通信
![[Pasted image 20230912194413.png]]
![[Pasted image 20230912194436.png]]


#### UART物理层(硬件)
- UART是异步串行全双工通信协议，没有时钟线，收发数据只能一位一位地在各自的数据线上传输
- 一根发送数据线（TXD），一根接收数据线（RXD）以及公共地线（GND）。
![[Pasted image 20230912202432.png]]
- UART电路包含一个Type-C型USB接口、一块USB转串口芯片CH340N。
#### URAT数据格式(软件)
- UART数据按照一定的格式打包组成数据帧，以帧为单位进行传输。
- UART的一帧数据由起始位、数据位、校验位、停止位和空闲位组成
![[Pasted image 20230912202540.png]]


1. ==起始位==
	- 长度为`1`位，起始位的逻辑电平为低电平。由于UART空闲状态时的电平为高电平，因此，`UART`在每一个数据帧的开始，需要先发出一个逻辑`0`，表示传输开始。
2. ==数据位==
	- 长度通常为`8`位，也可以为`9`位，每个数据位的值可以为逻辑`0`也可以为逻辑`1`，而且传输采用的是小端方式，即最低位（`D0`）在前，最高位（`D7`）在后。
3. ==校验位==
	- 在发送数据时, 数据位尾随的一位为奇偶校验位
4. ==停止位==
	- 长度可以是1位、1.5位或2位，通常情况下停止位都是1位。停止位是一帧数据的结束标志，为高电平。
5. ==空闲位==
	- 当数据传输完毕或当前没有数据传输时，线路上保持高电平。
#### 奇偶校验

1. 奇校验: 数据中 " 1 "的个数与校验位" 1 "的个数之和应为奇数 . 
	- 如果数据位中的逻辑1是奇数个，则校验位为0；如果数据位中的逻辑1是偶数个，则校验位为1。

2. 偶校验: 数据中 " 1 "的个数与校验位" 1 "的个数之和应为偶数，
	- 如果数据位中的逻辑1是奇数个，则校验位为1；如果数据位中的逻辑1是偶数个，则校验位为0。

校验位可以配置为奇校验或偶校验。在奇校验模式下，在偶校验模式下校验位不是必需项，可以将UART配置为没有校验位。接收字符时, 对" 1 "的个数进行校验, 如果发现不一致, 则说明传输数据过程中出现了差错

#### 传输速率

- UART传输速率用波特率来表示，即每秒传送码元的个数，单位为baud。
	由于UART使用NRZ（Non-Return to Zero，不归零）编码，因此UART的波特率即为每秒传输的二进制位数。
	在实际应用中，常用的UART波特率有4800、9600、19200、38400、57600和115200等。

- 尽管波特率越高，数据传输速率越快，但是采用较高的波特率往往会造成串口通信稳定性下降，
	更加容易导致电平状态采样不准确的问题，出现乱码现象。
	在需要保证数据稳定传输的场合，通常采用较低波特率。

#### 波特率和溢出率计算以及串口初始化(以工作模式1为例)

$$\begin{cases}
波特率=\frac{2^{SMOD}}{32}×溢出率_{T1}\\
溢出率_{T1}=\frac{f_{OSC}}{12X(256-TH1)}
\end{cases}$$

根据以上公式, 假设目标波特率$4800$, `SMOD`位取值是$1$, 此时`TH1`计算结果是`0xF3`
```c

//串口初始化

SCON = 0X50;            //设置 串口 工作模式1，并打开接收允许
PCON = 0X80;           //设置 波特率加倍(即其中的SMOD字段置为1)

// 波特率时钟
TMOD = 0X20;          //设置 定时器1 工作模式2（8位自动重装定时器定时器）
TL1  = 0XF3;              //设置 定时器1 计数初值，波特率为4800
TH1  = TL1;               //设置 定时器1重装值
TR1  = 1;                   //打开计数器


//打开中断
ES = 1;  
EA = 1;
```

#### UART原理

- 由于UART采用异步串行通信，没有时钟线，只有数据线。那么，收到一个UART原始波形，如何确定一帧数据？如何计算传输的是什么数据？下面以接收到的一个UART波形为例，假设UART波特率为115200 bps，数据位为8位，无奇偶校验位，停止位为1位。

第1步，在RXD引脚获取UART原始波形数据
![[Pasted image 20230912213038.png]]
第2步，按照波特率进行中值采样
![[Pasted image 20230912213049.png]]
第3步，确定起始位、数据位和停止位
![[Pasted image 20230912213059.png]]

#### 数据接收

- 通过串口实现数据的自收自发
（1）初始化串口中断。
（2）配置串口相关寄存器。
（3）根据波特率计算TH1与TL1的初值。
（4）在串口中断服务函数中，使用缓冲变量取出位于接收缓冲寄存器（SBUF）中的数据，并将其中的内容放入发送缓冲寄存器（SBUF）中，实现串口自收自发。



- ==直接查询:==
```c
if(1 == RI)                 //当接收中断请求标志位被置位
{
  Buffer = SBUF;      //将数据从接收缓冲寄存器中取出
  RI = 0;                    //清除接收中断请求位
}
```

- ==中断控制==
```c
void UART_Handler() interrupt 4 //串口中断服务函数
{
	if( 1== RI)                            //当接收中断请求标志位被置位
	{
		buffer = SBUF;                 //将数据从串口数据缓冲寄存器中取出
		RI = 0;                                //清除接收中断标志位
		SBUF = s_iBuffer;                 //将数据放入串口数据缓冲寄存器
		while(!TI);                        //等待发送数据完成
		TI = 0; 
	}
}
```

#### 多字符接收
```c
void UART_Handler() interrupt 4
{
	static unsigned char s_iCounter=0;    //定义计数变量
	if(1 == RI)
	{
		arrBuffer[s_iCounter] = SBUF;
		RI = 0;
		if(arrBuffer[s_iCounter]>='0'&&arrBuffer[s_iCounter]<='9')
		{
			s_iCounter ++;
		}
		……
	}
}
```

#### 数据发送
```c
void SendByte(unsigned char temp)
{
	SBUF = temp;
	while(!TI){};
	TI=0;
}
```
## 看门狗复位
#### 软件复位
- 单片机在正常运行程序的过程中，可以通过程序修改ISP控制寄存器中的值，实现单片机系统软复位。

ISP控制寄存器没有在reg52.h头文件中定义，因此需要以下代码定义该寄存器，才能在程序中调用。
```c
sfr ISP_CONTR = 0xE7; 
```
对ISP_CONTR寄存器中的SWRST位写“1”即可实现软件复位
```c
ISP_CONTR |= 0x20;       //执行软件复位
```

#### 外部RST引脚复位
对RST引脚施加两个机器周期以上的高电平信号，即可对单片机进行复位。51核心板上的复位按键即利用了外部RST引脚复位方法。
#### 上电/掉电复位
当单片机的供电电压低于门槛值，不足以支持单片机正常工作时，STC89系列微控制器内部所有的逻辑电路都会被复位，并在电压恢复后自动进行复位操作。

#### 看门狗复位以及溢出时间计算
看门狗实际上是一个定时器，因此也称为看门狗定时器，一般有一个输入操作，称“喂狗”。单片机正常工作的时候，每隔一段时间即喂一次狗。(注意, 尽量不要在定时器中断中进行喂狗操作)

定义看门狗控制寄存器, 因为头文件里没有定义
```c
sfr WDT_CONTR = 0xE1; 

```

但如果单片机死机，即超过规定时间不喂狗，看门狗定时器就会超时溢出，强制对单片机进行复位。
$$看门狗溢出时间=\frac{12×预分频系数×32768}{f_{OSC}}$$
- 其中，`32768`转换成十六进制即为`0x8000`，相当于15位计数器的最大计数值加1
- $f_{OSC}$为晶振频率，51核心板上的晶振为`12`MHz
- `WDT_CONTR`寄存器中`PS2`,`PS1`与`PS0`位设置看门狗定时器的预分频系数

使用以下代码启用看门狗并设置溢出时间为`524.2`ms。
```c
WDT_CONTR = 0x33; //0011 0011 ,即PS2=0,PS1=1,PS0=1 ,此时预分频系数是16
```

## Flash内部读写

-  51单片机编程方式根据代码下载方法不同可分为两种,分别是系统编程ISP和程序编程IAP
#### ISP ( In System Programming）

- 使用`STC-ISP`软件下载程序的编程方式，称为`ISP`。`STC89`系列微控制器在完全断电后上电时（也称为冷启动），会自动执行存储在`Flash`中内置的一段程序（称为`BootLoader`程序）。
- 不同的单片机厂商的`ISP`程序会存在差异，以`STC89`系列单片机为例，只要`STC89`系列微控制器在冷启动时串口上收到连续的`0x7F`，就会进入`ISP`模式，通过串口接收到的数据改写用户程序区，实现程序下载功能。
- 因此，在`STC89`系列微控制器下载程序时，通常需要先单击`STC-ISP`软件中的“下载/编程”按钮，再打开电源。
#### IAP ( In Application Programming）

- 而在程序中编写程序的编程方式，称为`IAP`。通过程序修改相关寄存器的值，并且写入相应的命令，即可触发IAP模式，实现对`Flash`的读写操作。

#### EEPROM（Electrically Erasable Programmable Read-Only Memory）

- `EEPROM`是一种非易失性存储器类型，通常用于存储和检索小量数据，如配置设置、校准参数、用户数据等。`EEPROM`的主要特点是可以电子擦除和重新编程，而不需要物理擦除，因此它适用于需要频繁写入和擦除的应用。
- 以`STC89C52RC`芯片为例, 其内部Flash可分为程序区和`EEPROM`区。其中，`8`KB大小的程序区地址范围为`0x0000~0x1FFF`，用于存储用户程序；`4`KB大小的`EEPROM`区地址范围为`0x2000~0x2FFF`，可用于断电时存储数据。
![[Pasted image 20230917165133.png]]

| 第一扇区 |          | 第二扇区 |          | 第三扇区 |          | 第四扇区 |          |
| -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| 起始地址 | 结束地址 | 起始地址 | 结束地址 | 起始地址 | 结束地址 | 起始地址 | 结束地址 |
| 0x2000   | 0x21FF   | 0x2200   | 0x23FF   | 0x2400   | 0x25FF   | 0x2600   | 0x27FF   |

| 第五扇区 |          | 第六扇区 |          | 第七扇区 |          | 第八扇区 |          |
| -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |
| 起始地址 | 结束地址 | 起始地址 | 结束地址 | 起始地址 | 结束地址 | 起始地址 | 结束地址 |
| 0x2800   | 0x29FF   | 0x2A00   | 0x2BFF   | 0x2C00   | 0x2DFF   | 0x2E00   | 0x2FFF   |

#### EEPROM的单字符读取操作

- <mark style="background: #CACFD9A6;">定义缓存变量</mark>  存放将要读取到EEPROM的数据
```c
unsigned char dat;
```
- <mark style="background: #CACFD9A6;">打开IAP功能，并写入读取命令</mark> 对`ISP_CONTR`寄存器中的`ISPEN`位写`1`打开`IAP`功能，并根据系统时钟频率对`WT2`、`WT1`以及`WT0`分别写入`0`、`0`、`1`设置`Flash`操作等待时间。
- <mark style="background: #CACFD9A6;">模式选择</mark> 对`ISP_CMD`寄存器中的`MS1`、`MS0`位写入`0`和`1`，允许对"`Data Flash/EEPROM`区"进行字节读取
```c
ISP_CONTR=0x81;      //打开IAP功能，允许编程改变Flash，设置Flash操作等待时间 
ISP_CMD = 0x02;        //允许对"Data Flash/EEPROM区"进行字节读取
```

- <mark style="background: #CACFD9A6;"> 写入`IAP`将要操作的地址</mark>: ( 需要重复操作 ) 假设需要写入的地址为`addr`，使用以下代码分别向`ISP_ADDRL`和`ISP_ADDRH`寄存器写入`IAP`操作地址。
```c
ISP_ADDRL = addr;             //写入IAP操作地址寄存器低位
ISP_ADDRH = addr >> 8;    //写入IAP操作地址寄存器高位
```

- <mark style="background: #CACFD9A6;">`IAP`功能触发</mark>: ( 需要重复操作 )对`ISP_TRIG`寄存器连续写入`0x46`和`0xB9`，即可触发`IAP`功能，让其根据`ISP_CMD`中的命令对`IAP`进行操作 (`46`和`B9`理解成一种触发的"trigger"暗号 )
```c
ISP_TRIG = 0x46;          //写入触发命令0x46 
ISP_TRIG = 0xB9;         //写入触发命令字0xB9
```

-  <mark style="background: #CACFD9A6;">读取数据</mark>: (需要重复操作 )触发`IAP`功能后，将需要读出的数据放进缓存变量中
```c
dat = ISP_DATA;         //将需要读出的数据放进缓存变量
```

- <mark style="background: #CACFD9A6;">`IAP`功能禁用: </mark>当所有数据读取完成后，为了防止误触发`IAP`，可以禁用此功能。`IAP`禁用操作不是必须的，但是本书建议，在不使用`IAP`功能时对其进行禁用操作。
- 对`ISP_CONTR`、`ISP_CMD`以及`ISP_TRIG`寄存器写入初始值`0x00`，即可禁用`IAP`功能
```c
ISP_CONTR = 0x00;          //禁用IAP读写EEPROM
ISP_CMD   = 0x00;            //待机模式，无ISP操作
ISP_TRIG  = 0x00;             //关闭IAP功能
```

#### EEPROM的扇区擦除
- 由于Flash存储介质的特性，只能对其写入“0”而不能写入“1”，因此需要对扇区内写入“1”，即擦除操作。在首次对扇区执行写入操作时，必须先执行扇区擦除操作。

- <mark style="background: #CACFD9A6;">打开IAP功能，写入擦除命令: </mark> 对ISP_CONTR寄存器中的ISPEN位写1打开IAP功能，并对WT2、WT1以及WT0位分别写入0、0、1设置Data Flash操作等待时间。
- <mark style="background: #CACFD9A6;">模式选择</mark>对ISP_CMD寄存器中的MS1、MS0位分别写入1和1，允许对Data Flash/EEPROM区进行扇区擦除.
```c
ISP_CONTR=0x81;      //打开IAP功能，允许编程改变Flash，设置Flash操作等待时间 // 1000 0001
ISP_CMD = 0x03;        //允许对Data Flash/EEPROM区进行扇区擦除
```

- <mark style="background: #CACFD9A6;">写入IAP操作的地址:</mark> `EEPROM`的擦除是按照扇区进行的。
- 假设需要擦除的扇区起始地址为`addr`（4位十六进制数），将`addr`的低位赋值给`ISP_ADDRL`寄存器，`addr`的高位赋值给`ISP_ADDRH`寄存器，代码如下。
```c
ISP_ADDRL = addr;
ISP_ADDRH = addr >> 8;
```

- <mark style="background: #CACFD9A6;">IAP功能触发</mark> :对`ISP_TRIG`寄存器连续写入`0x46`和`0xB9`，即可触发`IAP`功能，让其根据`ISP_CMD`中的命令对`IAP`进行操作，代码如下。
```c
ISP_TRIG = 0x46;          //写入触发命令0x46
ISP_TRIG = 0xB9;         //写入触发命令字0xB9
```

- <mark style="background: #CACFD9A6;">IAP功能禁用</mark> ：扇区擦除完成后，需要将IAP功能禁用。对ISP_CONTR、ISP_CMD以及ISP_TRIG寄存器写入初始值0x00，即可禁用IAP功能。
```c
ISP_CONTR = 0x00;          //禁用ISP读写EEPROM
ISP_CMD   = 0x00;          //待机模式，无ISP操作
ISP_TRIG  = 0x00;          //关闭IAP功能
```

#### EEPROM的单字节写入操作
- <mark style="background: #CACFD9A6;">打开IAP功能，并写入“写”命令</mark> 对`ISP_CONTR`寄存器中的`ISPEN`位写`1`打开`IAP`功能，并对`WT2`、`WT1`以及`WT0`位分别写入`0`、`0`、`1`设置`Data Flash`操作等待时间。
- <mark style="background: #CACFD9A6;">模式选择</mark> 对`ISP_CMD`寄存器中的`MS1`、`MS0`位分别写入`1`和`0`，允许对"`Data Flash/EEPROM`区"进行字节写入
```c
ISP_CONTR=0x81; //打开IAP功能，允许编程改变Flash，设置Flash操作等待时间 
ISP_CMD = 0x01;
```

- <mark style="background: #CACFD9A6;">写入IAP操作的地址</mark>  (需要重复操作) 假设需要写入的地址为`addr`（`4`位十六进制数），将`addr`的低位赋值给`ISP_ADDRL`寄存器，`addr`的高位赋值给`ISP_ADDRH`寄存器，代码如下。
```c
ISP_ADDRL = addr;               //写入IAP操作地址寄存器低位
ISP_ADDRH = addr >> 8;      //写入IAP操作地址寄存器低位
```

- <mark style="background: #CACFD9A6;">写入数据</mark>  (需要重复操作) 假设已经将需要写入的数据存入`unsigned char`型的变量`dat`，使用以下代码将需要写入的数据放进`ISP_DATA`寄存器。
```c
 ISP_DATA = dat;          //将需要写入的数据放进ISP_DATA
```

- <mark style="background: #CACFD9A6;">IAP功能触发</mark> (需要重复操作) 对`ISP_TRIG`寄存器连续写入`0x46`和`0xB9`，即可触发IAP功能，让其根据`ISP_CMD`中的命令对`EEPROM`区进行相应的操作
```c
ISP_TRIG = 0x46;          //对ISP_TRIG寄存器写入触发命令0x46
ISP_TRIG = 0xB9;         //对ISP_TRIG寄存器写入触发命令0xB9
```

- <mark style="background: #CACFD9A6;">IAP功能禁用</mark> 需要将`IAP`功能禁用。对`ISP_CONTR`、`ISP_CMD`以及`ISP_TRIG`寄存器写入初始值`0x00`，即可禁用`IAP`功能
```c
ISP_CONTR = 0x00;          //禁用ISP读写EEPROM
ISP_CMD   = 0x00;          //待机模式，无ISP操作
ISP_TRIG  = 0x00;          //关闭IAP功能
```

#### EEPROM 注意事项
（1）必须先对扇区进行擦除，再写入。
（2）在单片机工作电压偏低时，不建议进行IAP读写Flash操作。
（3）由于IAP操作仅支持以字节方式读取或写入，建议需要同一次修改的数据放在同一个扇区中，不需要同一次修改的数据放在其他扇区，不需要把扇区中的512字节都用满。如果在一个扇区内存放了大量的数据，需要修改其中的一小部分时，则需要先将该扇区中的数据读出至RAM中，然后擦除整个扇区，再将数据从RAM写入至Flash中。
（4）在STC-ISP软件中，可以在下载程序时对EEPROM区进行擦除。在勾选“本次下载需要修改硬件选项”后，如果勾选“下次下载用户程序时擦除用户EEPROM区”选项，则EEPROM区中的所有内容将会被擦除。
![[Pasted image 20230917214337.png]]


## TCON 定时器控制寄存器( Timer Control )( `0x88`可寻址位 )

| {TCON} | 0x88 | TF1(7) | TR1(6) | TF0(6) | TR0(5) | IE1(4) | IT1(3) | IE0(1) | IT0(0) |    
| ---- | ---- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | 

==**TF (Timer Flag)：==TF 是定时器溢出标志位Timer Overflow）,通常用于指示定时器是否已经计数到达设定的阈值。** 
- 当定时器的计数值达到预设的阈值时，TF 标志会被置位(一般设置成1), 这通常被称为表示定时器已经完成计数。
- 通常，在定时器中断中，处理器会检查 TF 标志来确定是否需要执行特定的任务。(但其实并不常用)

==**TR(Time Run):==  TR 启动控制位控制定时器的启动和停止，即是否开始计数。**

- **`(TR = 0)`：定时器停止。** 当 TR 位被设置为 0 时，定时器将停止计数。  
- **`(TR = 1)`：定时器开始。** 当 TR 位被设置为 1 时，定时器开始计数。

==**IT (Interrupt Type):==用于描述外部中断触发的方式或类型。中断类型可以包括不同的触发方式**

-   **`(IT = 1) `: 脉冲触发（Edge-Triggered）：** 当信号的边沿（上升沿或下降沿）发生变化时，触发中断。脉冲触发中断通常在边沿的瞬间触发，并且只有在边沿改变时才会重新触发。
-   **`(IT = 0)` : 电平触发（Level-Triggered）：** 当信号保持在特定电平上（高电平或低电平）时触发中断。电平触发中断会在信号保持在触发电平上时持续触发，直到信号变为另一个电平。

==**IE (Interrupt Enable) ==是外部中断使能位，用于控制是否允许定时器产生中断请求**

-  **`(IE = 1)`  有中断请求** ：这将触发处理器进入中断服务程序，允许处理特定的任务，然后返回到主程序。定时器中断通常用于周期性执行任务、时间测量和同步操作。
-  **`(IE = 0)`  无中断请求 ：** 如果不需要触发中断，您可以将中断请求禁用。在这种情况下，定时器只会进行计数，而不会干扰处理器的正常执行。

## IE  中断允许寄存器( Interrupt Enable ) ( `0xA8`可寻址位 )

| {IE}  | 0xA8 | EA(7) | -   | ET2(5) | ES(4) | ET1(3) | EX1(2) | ET0(1) | EX0(0) | 
| --- | ---- | ----- | --- | ------ | ----- | ------ | ------ | ------ | ------ |

==**ET (Enable Time)**==

-   **当"ET"位被设置为 1** 时，相关的计时器或定时器的中断将被启用。这意味着当计时器达到设定的阈值时，可会产生中断请求或触发某种定时事件。
-   **当"ET"位被设置为 0** 时，相关的计时器或定时器的中断将被禁用。这意味着计时器将不会产生中断请求或触发定时事件，处理器将继续执行主程序。

**==EX (Enable Interrupt)  ==**

-  **当"EX"位被设置为 1** 时，相关的外部中断将被启用。这意味着当外部事件发生时，会产生中断请求，处理器将跳转到中断服务程序来处理事件。
-  **当"EX"位被设置为 0** 时，相关的外部中断将被禁用。这意味着即使外部事件发生，也不会产生中断请求，处理器将继续执行主程序。

==**ES (Enable Serial Interrupt)**==

- **当ES位被设置为 1** 时，表示允许串口通信中断，这意味着当有串口通信相关的中断事件发生时，CPU将响应这些中断请求并执行相应的中断服务程序。
- **当ES位被清为  0** 时，表示禁用串口通信中断，CPU将忽略与串口通信相关的中断请求。

## IP 中断优先级控制寄存器 ( Interrupt Priority ) ( `0xB8`可寻址位 )

| {IP}  | 0xB8 | -   | -   | PT2(5) | PS(4) | PT1(3) | PX1(2) | PT0(1) | PX0(0) |
| --- | ---- | --- | --- | ------ | ----- | ------ | ------ | ------ | --- |

==**PT (Priority Toggle Bit)：**== "PT" 允许您切换或切换中断的优先级级别。

- **当 "PT" 位被设置为 1 时**，某些系统可能会在连续的中断请求之间交替选择优先级，以确保平均分配系统资源。
- **当 "PT" 位被清除为 0 时**，可能会使用固定的优先级顺序。

==**PX (External Interrupt Priority)：**== 每个外部中断源可能对应一个 "PX" 位，用于指定该外部中断的优先级。

- **设置较高的 "PX" 值表示较高的优先级。**(00(最低),01(较低),10(较高),11(最高))

==**PS (Priority Serial):**== 串口中断优先级控制位, 初始值为0，由软件置1或清零。注意: (`IP=1`,即`0001`,刚好`PT`位为`1`)

- **当"PT"位被设置为0时**：设置串口中断为低优先级
- **当"PT"位被设置为1时**：设置串口中断为高优先级


## TMOD 定时器模式寄存器 (Timer Mode) (`0x89`不可寻址位)

| {TMOD} | 0x89 | GATE(7) | C/T(6) | M1(5) | M0(4) | GATE(3) | C/T(2) | M1(1) | M0(0)  |
| ---- | ---- | ------- | ------ | ----- | ----- | ------- | ------ | ----- | --- |
	左边四个位是定时器1,右边四个位是定时器2
```c

TMOD = 0x01 ; //配置了定时器 ,
//GATE=0即允许TRx启动计数器, 
//C/T=0即模式选择成定时器, 
//M1=0,M0=1即选择了方 "01" 的定时方式

```

==**GATE**== 门控位用于配置定时器计数的启动方式。

- **GATE = 0**：允许 `TCON` 寄存器的 位字段 `TRx ` 启动计数器
- **GATE = 1**：允许 外部中断1` INTx` 启动计数器。

==**C/T (count or time )**== 字段通常用于配置定时器的计数/计时模式，即选择定时器是作为计数器还是计时器来使用

- **C/T = 0**：计数模式。在这种模式下，定时器被配置为一个计数器，用于计算外部信号的脉冲数量。当定时器的计数器达到设定值时，通常会触发某个事件，如中断。    
- **C/T = 1**：计时模式。在这种模式下，定时器被配置为一个计时器，用于测量时间间隔。定时器会根据外部时钟源的脉冲计数，当计数达到设定值时，可能会触发某个事件，如中断。

==**M (mode)**==两个字段（M1和M2）通常是用来设置定时器的工作模式的。这个字段决定了定时器如何计数和操作。

| M1  | M0  | 工作模式 | 说明                         |
| --- | --- | -------- | ---------------------------- |
| 0   | 0   | 模式0    | 13位定时器/计数器            |
| 0   | 1   | 模式1    | 16位定时器/计数器            |
| 1   | 0   | 模式2    | 8位定时器/计数器，可自动重载 |
| 1   | 1   | 模式3    | 两组独立的8位定时器          |

-   **M = 00** (mode0)：
	- 13 位计数模式。在这种模式下，定时器通常有一个 13 位的计数器，可以对计数范围进行更大的控制。
-   **M = 01** (mode1)：
	- 16 位计数模式。这是一种常见的计数模式，在这种模式下，定时器使用一个 16 位的计数器，可以计数更大的时间间隔。(也就是65536)
-   **M = 10** (mode2)：
	- 8 位自动重装载计数模式。在这种模式下，定时器会在计数达到最大值时自动重新加载初始值，并继续计数, 就是当`TLx`低位初值溢出的时候,会自动读取`THx`高位中的值作为新的计数初值。这适用于需要定期触发的应用，例如产生精确的定时中断。
-   **M = 11** (mode3)：
	- 模式保留或具体实现取决于微控制器的架构。C51的单片机中, 只有 定时器/计数器0 有, 但是 定时器/计数器1 并没有这个功能, 只有前三个模式

## TH/TL计数高位低位寄存器( Time High/Low) 

{TH}  和 {TL} 通常是指微控制器中定时器的高位和低位寄存器，用于存储定时器的计数值。

| 名称 | 地址 | 描述       |
| ---- | ---- | ---------- |
| TL0  | 0x8A | 计数值高位 |
| TL1  | 0x8B | 计数值低位 |
| TH0  | 0x8C | 计数值高位 |
| TH1  | 0x8D | 计数值高位           |

## XICON 辅助中断控制寄存器 ( External Interrupt Control )  ( `0xC0`可寻址位 )

|{XICON} | 0xC0 | PX3(7) | EX3(6) | IE3(5) | IT3(4) | PX2(3) | EX2(2) | IE2(1) | IT2(0) |
| ----- | ---- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |

该辅助寄存器中, 
	有定时器控制的位字段 **IT2 IT3** 以及 **IE2 IE3**
	有中断允许控制的位字段 **EX2 EX3** 
	有中断优先级控制的位字段 **PX2 PX3** 

## IPH 中断优先级控制寄存器高位 ( Interrupt Priority High) ( `0xB7` 不可寻址位 )

| {IPH} | 0xB7 | PX3H(7) | PX2H(6) | PT2(5) | PSH(4) | PT1H(3) | PX1H(2) | PT0H(1) | PX0H(0) |
| --- | ---- | ------- | ------- | ------ | ------ | ------- | ------- | ------- | ------- |


==PSH(Priority Set High)==  用于配置高优先级中断的优先级。
- 它可以控制高优先级中断之间的优先级顺序，以确定哪个高优先级中断在中断发生时首先得到服务。(00(最低),01(较低),10(较高),11(最高))

注意: 如果是IPH这样的寄存器,只能直接修改字节,进行总线操作

```c
PX0 = 1; //可位寻址可以直接赋值位字段 

IPH = 0x01; //不可寻址可以直接赋值位字段
```

## PCON 电源管理寄存器( PowerControl )(`0x87`不可寻址位)

| {SCON} | 0x98 | SMOD(7) | (6) |(5) | (4) | GF1(3) | GF0(2) | (1) | (0) |
| --- | ---- | ------- | ------- | ------ | ------ | ------- | ------- | ------- | ------- |

PCON寄存器中只有一位字段跟串行口工作有关，其余的这里暂不介绍

==SMOD（Serial Mode）:== 波特率倍增位，当串行口以模式1、模式2、模式3工作时，该字段会作用，初始值为0，由软件置1或清零。

- **SMOD=0:** 串口通信波特率不加倍
- **SMOD=1:** 串口通信波特率加倍

==GF ( General Flag):== 通用工作标志位, 用户可以自由使用

## SCON 串口控制寄存器(Serial Control)(`0x98`可寻址位)

| {SCON} | 0x98 | SM0(7) | SM1(6) | SM2(5) | REN(4) | TB8(3) | TR8(2) | TI(1) | RI(0) |
| --- | ---- | ------- | ------- | ------ | ------ | ------- | ------- | ------- | ------- |
```c
SCON = 0X50;//0101 0000 //设置 串口 工作模式1(SM=01)，并打开REN接收允许
PCON = 0X80;           //设置 波特率加倍 1000000

// 以下是之前定时器的内容

TMOD = 0X20;          //设置 定时器1 工作模式2（8位自动重装定时器定时器）
TL1  = 0XF3;              //设置 定时器1 计数初值，波特率为4800
TH1  = TL1;               //设置 定时器1重装值
TR1  = 1;                   //打开计数器1
```

==**TI (Transmit Interrupt)**：== 发送中断标志位，当一个字节的数据发送完成时，会被置位 , 初始值为0

- 在工作模式0中，当8位数据发送结束时，由硬件置1。
- 在其他工作模式中，则在停止位开始发送时由硬件置1。

==**RI (Receive Interrupt) :**==  接收中断标志位，当一个字节的数据接收完成时，会被置位。初始值为0且之后必须由软件清零

- 在工作模式0中，当数据接收结束时，由硬件置1。
- 在其他工作模式中，则在停止位开始接收时由硬件置1。

**==SM1/SM2(Serial Mode) :==** 串口工作模式选择位。初始值为0，由软件置1或清零。
STC89系列微控制器内部集成一个全双工串口通信模块，设有相互独立的接收、发送缓冲器，可以同时发送和接收数据，具有4种工作模式

| SM0 | SM1 | 工作模式 | 功能                           |
| ---- | --- | -------- | -------------------------- |
| 0    | 0   | 模式0    | 8位同步移位寄存器          |
| 0    | 1   | 模式1    | 10位帧格式UART，波特率可变 |
| 1    | 0   | 模式2    | 11位帧格式UART，波特率固定 |
| 1    | 1   | 模式3    | 11位帧格式UART，波特率可变 |

- **SM=00：** 串并转换
- **SM=01：** 两机通信（点对点）
- **SM=10：** 多机通信
- **SM=11：** 可变波特率的奇偶校验（单机通讯）或主从式通讯

==**REN （Receive Enable）：**==串口通信接收允许位。初始值为0，由软件置1或清零。

- **REN=0：** 禁止串口接收
- **REN=1：** 允许串口接收

## SBUF 串行缓冲寄存器 (Serial Buffer )(`0x99`不可寻址位)
- ` SBUF `寄存器用于存储将要发送或接收的数据字节。当要发送数据时，将数据写入 SBUF 寄存器，然后 `UART/USART` 模块将该数据发送到外部设备.
- 与串口接收操作相关的寄存器为`SBUF`，接收缓冲寄存器和发送缓冲寄存器在物理上是两个寄存器，但在逻辑上是一个寄存器。
- 其中，接收缓冲寄存器只能读出而不能写入，发送缓冲寄存器只能写入而不能读出，
- 两个缓冲寄存器可以共用一个地址`0x99`。

## ISP_CONTR  "ISP-IAP"控制寄存器 （In-System Programming Control Register）(`0xE7`不可寻址)

| {ISP_CONTR} |  0xE7 | ISPEN(7) | SWBS(6) | SWRST(5) | -   | -   | WT2(2) | WT1(1) | WT0(0) |
| --------- |  ---- | ----- | ---- | ----- | --- | --- | --- | --- | --- |

==**ISEPN**：==  ISPEN 字段用于启用或禁用这种在线编程功能。

- 当 ISPEN 设为 1 时，表示启用 ISP 功能，允许对芯片进行在线编程。
- 当 ISPEN 设为 0 时，表示禁用 ISP 功能，不允许对芯片进行在线编程。

==**SWBS (Software Byte Select):**== 软件复位后启动程序区选择位,初始值为0，由软件置1或清零。

- SWBS = 0： 软件复位后从用户程序区启动
- SWBS = 1： 软件复位后从ISP程序区启动

==**SWRST(Software Reset):**==  软件复位使能位。初始值为0，由软件置1，硬件清零通常用于通过软件控制来重置整个MCU，将其恢复到初始状态，类似于硬件复位但是由软件触发。

- SWRST = 0：无操作；
- SWRST = 1：执行软件复位

**==WT (Waiting Time) :==**  等待时间位(单位是机器周期).  每次写入和擦除都需要一些时间来等待, 我们需要通过`WT0`, `WT1`, `WT2`这三个字段来进行配置

| WT2 | WT1 | WT0 | 读操作 | 写操作 | 扇区擦除操作 | 对应的推荐系统时钟 |
| --- | --- | --- | ------ | ------ | ------------ | ------ |
| 0   | 1   | 1   | 6      | 30     | 5471         | ≤5MHz  |                    
| 0   | 1   | 0   | 11     | 60     | 10942        | ≤10MHz |                  
| 0   | 0   | 1   | 22     | 120    | 21185        | ≤20MHz(一般选这个) |                    
| 0   | 0   | 0   | 43     | 240    | 43769        | ≤40MHz |                 



## WDT_CONTR 看门狗控制寄存器 (Watchdog Timer Control Register） (`0xE1`不可寻址)

|     {WDT_CONTR} | 0xE1 | -   | -   | EN_WDT(5) | CLR_WDT(4) | IDLE_WDT(3) | PS2(2) | PS1(1) | PS0(0) |
| --- | ---- | --- | --- | ------ | ------- | -------- | --- | --- | --- |

==**EN_WDT( Enable_WatchdogTimer):**== 看门狗允许位。初始值为0，由软件置1或清零。

- EN_WDT = 0 :  禁用看门狗
- EN_WDT = 1 :  启用看门狗

==**CLR_WDT( Clear_WatchdogTimer) :**== 看门狗清“0”位。初始值为0，由软件置1，硬件清零。

- CLR_WDT = 1:  看门狗重新计时, 即喂狗操作

==**IDLE_WDT ( IDLE_WatchdogTimer):**== 看门狗空闲模式位。初始值为0，由软件置1或清零。

- IDLE_WDT = 1:  看门狗定时器在空闲模式时仍然计数
- IDLE_WDT = 0:  看门狗定时器在空闲模式时不计数

==**PS :**== 看门狗定时器预分频值设置位, 以下是`12MHZ`下对应系数的看门狗溢出时间

| PS2 | PS1 | PS0 | 预分频系数 | 看门狗溢出时间(ms) |
| --- | --- | --- | ---------- | ------------------ |
| 0   | 0   | 0   | 2          | 65.5               |
| 0   | 0   | 1   | 4          | 131                |
| 0   | 1   | 0   | 8          | 262.1              |
| 0   | 1   | 1   | 16         | 524.2              |
| 1   | 0   | 0   | 32         | 1048.5             |
| 1   | 0   | 1   | 64         | 2097.1             |
| 1   | 1   | 0   | 128        | 4194.3             |
| 1   | 1   | 1   | 256        | 8338.6             |

## ISP_ 各类寄存器 (In-System Programming)


| 名称      | 描述                      | 地址 | 7     | 6    | 5     | 4   | 3   | 2   | 1   | 0   |     |     |     |     |     |     |     |     |     |
| --------- | ------------------------- | ---- | ----- | ---- | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| {ISP_DATA}  | ISP-IAP数据寄存器         | 0xE2 |       |      |       |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| {ISP_ADDRH} | ISP-IAP操作地址寄存器高位 | 0xE3 |       |      |       |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| {ISP_ADDRL} | ISP-IAP操作地址寄存器低位 | 0xE4 |       |      |       |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| {ISP_CMD}   | ISP-IAP命令寄存器         | 0xE5 | -     | -    | -     | -   | -   | -   | MS1 | MS0 |     |     |     |     |     |     |     |     |     |
| {ISP_TRIG}  | ISP-IAP命令触发寄存器     | 0xE6 |       |      |       |     |     |     |     |     |     |     |     |     |     |     |     |     |     |


==**MS (Mode Select)**== 模式选择位. MS1和MS0的不同组合用于定义不同的操作模式，如无IAP操作、字节读取、字节写入和扇区擦除。

|MS1|MS0|说明|
|---|---|---|
|0|0|无IAP操作|
|0|1|允许对Data Flash/EEPROM区进行字节读取|
|1|0|允许对Data Flash/EEPROM区进行字节写入|
|1|1|允许对Data Flash/EEPROM区进行扇区擦除|


## ASCII对照表
- 单片机内部存储和表示英文字母和各类标点符号，需要借助一种通用的字节数据与字符之间的转换关系，即ASCII码。 
```
| ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 | ASCII值 | 控制字符 |
| ------- | -------- | ------- | -------- | ------- | -------- | ------- | -------- |
| 0       | NUL      | 32      | (space)  | 64      | @        | 96      | `        |
| 1       | SOH      | 33      | !        | 65      | A        | 97      | a        |
| 2       | STX      | 34      | "        | 66      | B        | 98      | b        |
| 3       | ETX      | 35      | #        | 67      | C        | 99      | c        |
| 4       | EOT      | 36      | $        | 68      | D        | 100     | d        |
| 5       | ENQ      | 37      | %        | 69      | E        | 101     | e        |
| 6       | ACK      | 38      | &        | 70      | F        | 102     | f        |
| 7       | BEL      | 39      | '        | 71      | G        | 103     | g        |
| 8       | BS       | 40      | (        | 72      | H        | 104     | h        |
| 9       | HT       | 41      | )        | 73      | I        | 105     | i        |
| 10      | LF       | 42      | *        | 74      | J        | 106     | j        |
| 11      | VT       | 43      | +        | 75      | K        | 107     | k        |
| 12      | FF       | 44      | ,        | 76      | L        | 108     | l        |
| 13      | CR       | 45      | -        | 77      | M        | 109     | m        |
| 14      | SO       | 46      | .        | 78      | N        | 110     | n        |
| 15      | SI       | 47      | /        | 79      | O        | 111     | o        |
| 16      | DLE      | 48      | 0        | 80      | P        | 112     | p        |
| 17      | DC1      | 49      | 1        | 81      | Q        | 113     | q        |
| 18      | DC2      | 50      | 2        | 82      | R        | 114     | r        |
| 19      | DC3      | 51      | 3        | 83      | S        | 115     | s        |
| 20      | DC4      | 52      | 4        | 84      | T        | 116     | t        |
| 21      | NAK      | 53      | 5        | 85      | U        | 117     | u        |
| 22      | SYN      | 54      | 6        | 86      | V        | 118     | v        |
| 23      | ETB      | 55      | 7        | 87      | W        | 119     | w        |
| 24      | CAN      | 56      | 8        | 88      | X        | 120     | x        |
| 25      | EM       | 57      | 9        | 89      | Y        | 121     | y        |
| 26      | SUB      | 58      | :        | 90      | Z        | 122     | z        |
| 27      | ESC      | 59      | ;        | 91      | [        | 123     | {        |
| 28      | FS       | 60      | <        | 92      | \        | 124     | |        |
| 29      | GS       | 61      | =        | 93      | ]        | 125     | }        |
| 30      | RS       | 62      | >        | 94      | ^        | 126     | ～       |
| 31      | US       | 63      | ?        | 95      | _        | 127     | DEL      |


```
