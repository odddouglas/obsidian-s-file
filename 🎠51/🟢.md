
#### 延时函数
```c
static void delay(int nms)
{
    unsigned int i, j;
    for (i = 0; i < nms; i++)
    {
        for (j = 0; j < 123; j++)
        {
        }
    }
}
```

#### 串口配置
```c
void UART_Init(void)
{
    SCON = 0x50;  //设置 串口 工作模式1，并打开REN接收允许
    PCON &= 0XEF; //设置 波特率加倍(即其中的SMOD字段置为0.其他字段不变 )

    // 波特率时钟
    TMOD = 0X20; //设置 定时器1 工作模式2（8位自动重装定时器定时器）
    TL1 = 0XFD;  //设置 定时器1 计数初值，波特率为4800
    TH1 = TL1;   //设置 定时器1重装值
    TR1 = 1;     //打开计数器
    
    ES = 1; //打开中断
    EA = 1;
}
```

#### 定时器配置
```c
void Init_Timer0()  // 中断初始化
{
    TMOD |= 0X01;   // 把定时器0的工作模式设置为16位定时器
    
   
    // 设置初始值
    TH0 = 0XFC;
    TL0 = 0X18;
    
    TR0 = 1;        // 定时器0——1启动，0停止
    ET0 = 1;        // 允许定时器中断——小门
     
    EA = 1;         // 总中断允许标志位，0断，1通——大门
}
```

#### 串口单字节发送
```c
void SendByte_UART(unsigned char byte)  //
{
	SBUF = byte;
	while (!TI)
	{
	} // 等待发送完成
	TI = 0;
}
```

#### IAP功能触发函数
```c
static void Trigger_IAP()   
{
    ISP_TRIG=0x46;  //命令触发寄存器写入触发命令
    ISP_TRIG=0xb9;
}
```

#### IAP功能禁用函数
```c
static void Ban_IAP()
{
  ISP_CONTR = 0x00;          //禁用IAP读写EEPROM
  ISP_CMD   = 0x00;          //无IAP操作
  ISP_TRIG  = 0x00;          //关闭IAP功能
}
```


#### IAP读取数据函数
```c
unsigned char ByteRead_IAP(unsigned int addr)
{
    unsigned char dat; //定义数据缓存变量
    ISP_CONTR = 0x81;  //打开IAP功能，允许编程改变Flash，设置Flash操作等待时间
    ISP_CMD = 0x01;    //允许对"Data Flash/EEPROM区"进行字节读取

    ISP_ADDRL = addr;      // IAP操作地址寄存器低位
    ISP_ADDRH = addr >> 8; // IAP操作地址寄存器高位

    Trigger_IAP();   //触发IAP功能
    dat = ISP_DATA; //将需要读出的数据放进缓存变量
    Ban_IAP();   //禁用IAP功能
    return dat;     //将读取到的数据作为返回值
}
```

#### IAP写入数据函数
```c
void ByteWrite_IAP(unsigned int addr, unsigned char dat)
{
    ISP_CONTR = 0x81; //打开IAP功能，允许编程改变Flash，设置Flash操作等待时间
    ISP_CMD = 0x02;   //允许对"Data Flash/EEPROM区"进行字节写入

    ISP_ADDRL = addr;      // IAP操作地址寄存器低位
    ISP_ADDRH = addr >> 8; // IAP操作地址寄存器高位
    ISP_DATA = dat;        //将需要写入的数据放进ISP_DATA

    Trigger_IAP(); //触发IAP功能
    Ban_IAP();     //禁用IAP功能
}

```

#### IAP扇区擦除函数
```c
void IAPSectorErase(unsigned int addr)
{
    ISP_CONTR = 0x81; //打开IAP功能，允许编程改变Flash，设置Flash操作等待时间
    ISP_CMD = 0x03;   //允许对"Data Flash/EEPROM区"进行扇区擦除

    ISP_ADDRL = addr;      //写入IAP操作地址寄存器低位
    ISP_ADDRH = addr >> 8; //写入IAP操作地址寄存器高位

    IAPTrigger(); //触发IAP功能
    IAPDisable(); //禁用IAP功能
}
```

#### 数码管段码
```c
//共阴不带小数点0-F段码为：
unsigned char leddata[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
```

```c
//共阴带小数点0-F段码为
unsigned char leddata[]={0xbf,0x86,0xdb,0xcf,0xe6,0xed,0xfd,0x87,0xff,0xef,0xf7,0xfc,0xb9,0xde,0xf9,0xf1};
```

```c
//共阳不带小数点0-F段码为：
unsigned char leddata[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e};
```

```c
//共阳带小数点0-F段码为
unsigned char leddata[]={0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10,0x08,0x03,0x46,0x21,0x06,0x0e};
```

#### 数码管四位动态显示
```c
void Nixie_show4(unsigned char num)
{
    //数码管显示
    SEL0 = 0; // 第一位数码管显示
    P0 = leddata[num / 1000];
    Delay(2);
    SEL0 = 1;

    SEL1 = 0; // 第二位数码管显示
    P0 = leddata[(num % 1000) / 100];
    Delay(2);
    SEL1 = 1;

    SEL2 = 0; // 第三位数码管显示
    P0 = leddata[(num % 100) / 10];
    Delay(2);
    SEL2 = 1;

    SEL3 = 0; // 第四位数码管显示
    P0 = leddata[num % 10];
    Delay(2);
    SEL3 = 1;

    num = (KEY == 0 || num > 9999) ? 0 : num; // 用KEY清零
}

```