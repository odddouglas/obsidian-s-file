
## ##⏹️交换两个变量的值
```c 
void swap(int *pa,int *pb) 
{
	int t = *pa;
	*pa = *pb;
	*pb = t;
}
```
## ##⏹️指针适用场景
	1.函数返回多个值，某些值就只能通过指针返回。
	 (传入的参数实际上是需要保存带回的结果的变量)
	2.函数返回运算的状态，结果通过指针返回
	常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错: -1或0
	(在文件操作会看到大量的例子)但当数值都是有效的可能结果时，就得分开返回
## ##⏹️数组变量是特殊的指针 
```c
int sum(int *ar,int n);    
int sum(int ar[],int n);  
```
## ##⏹️指针的运算是单元的加减
	c语言中一般只讨论指针加、减运算，乘、除等其他算术运算是没有意义。
	指针加、减多用于数组(或者连续内存空间)。
	当指针变量p指向数组元素时，p+1指向下一个数纠元素，p-1指向上一个数组元素。
	p+1、p-1并不是数学中的加1、减1
	而是表示移动一个“单元” 对于int类型来讲一个单元占4个字节
	因此，p和p+1的值相差1个“单元”4个字节。
	指针加一 就是加一个sizeof(基础数据类型)例如char是一格一格来 int是四格四格来
```c
int a[5]=(1,2,3,4,5);
int* p1=&a[0];
int* p2=&a[2];
printf("p1=%p\n",p1);
printf("p2=%p\n",p2);
printf("%d\n",p2-p1);
```
## ##⏹️指针相减就是地址相减
	在C语言中，两个指针相加是没有意义的，而两个指针相减却有特殊的意义
	不过两个指针都指向同一个数组中的元素时才有意义。
	以数组int a[5]为例: 假设p2指向元素a[2]，p1指向元素a[o]
	p2-p1并不是单纯的减法运算，而是表示p2与p1之间隔了多少个数组元素。
	注意: 指针的差值 除以 sizeof(数据基础类型) 意思是 两个指针之间差了几个单元
## ##⏹️`*(a+i) <=> a[i]` 
```c
int a[5]=(1,2,3,4,5);
int i;
int len=sizeof(a)/sizeof(int);
for (i=0;i<len;i++)
{
printf("%d",*(a+i));
}
```
	a+0 等价于&a[0]，a+0指向a[0]:
	a+1等价于&a[1]，a+1指向a[1];
	a+2 等价于&a[2]，a+2指向a[2];
	可以认为a+i等价于&a[i]，ati指向a[i]
	那么*(a+i)就是a+i所指向的数组元素a[i]。因此，*(a+i)与a[i]等价。

## ##⏹️关于`*p++` 和 0地址
```c 
*p++
```
	取出p所指的那个数据来，完事之后顺便把p移到下一个位置去
	*的优先级虽然高，但是没有++高
	常用于数组类的连续空间操作
```c
0地址
```
	当然你的内存中有0地址，但是0地址通常是个不能随便碰的地址
	所以你的指针不应该具有0值因此可以用0地址来表示特殊的事情:
	如:返回的指针是无效的
	如:指针没有被真正初始化(先初始化为0)
	NULL是一个预定定义的符号，表示0地址。有的编译器不用0来表示0地址
## ##⏹️关于指针的类型转换
```c
void*  
```
	//表示不知道指向什么东西的指针,计算时与char*相同(但不相通)
```c
int *p = &i; void*q = (void*)p;
```
	指针也可以转换类型
	这并没有改变p所指的变量的类型，而是让赋值的后人用不同的眼光通过p看它所指的变量
	无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
	但是指向不同类型的指针是不能直接互相赋值的。
	这是为了避免用错指针
## ##⏹️关于指针的大小比较运算
	<,<=,==,>,>=,!= 都可以对指针做
	比较的是它们在内存中的地址
	数组中的单元的地址肯定是线性递增的
## ##⏹️const数组及其保护机制
```c
//这些是啥意思9  
int i；  
const int *p1;
int const *p2;  
int *const p3;  
//判断哪个被const了的标志? 是const在*的前面还是后面?
```
- 如果const在`*` 的前面，表示它所指的东西不能被修改
- 如果const在`*` 的后面，表示指针不能被修改
```c
const int a[] = {l,2,3,4,5,6,};
	```
	数组变量已经是const的指针了
	这里的const表明数组的每个单元都是const int
	所以必须通过初始化进行赋值
```c
int sum(const int a[],int length);
```
	因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值
	为了保护数组不被函数破坏，可以设置参数为const

## ##⏹️函数指针介绍
函数指针是一种指向函数的指针变量，可以用来调用函数或者作为参数传递⁴。函数指针的定义方式为：
`返回值类型 (*指针变量名) (参数列表);`
例如，如果要定义一个指向返回值为int，参数为两个int的函数的指针，可以这样写：
`int (*p) (int x, int y);`
然后可以把p赋值给一个已经存在的这样的函数，比如：
`p = max; //假设max是一个求两个数最大值的函数`
或者直接用p来调用这样的函数，比如：
`int result = p(3, 5); //相当于调用max(3, 5)`
下面是一个完整的例子²：
```c
#include <stdio.h>
//定义一个求两个数最大值的函数
int max(int a, int b)
{
    return a > b ? a : b;
}
//定义一个求两个数最小值的函数
int min(int a, int b)
{
    return a < b ? a : b;
}
//定义一个接受两个整数和一个函数指针作为参数，并返回该函数调用结果的函数
int func(int x, int y, int (*p)(int,int))
{
    return p(x,y);
}
//主程序
int main()
{
    //定义并初始化一个指向max函数的指针
    int (*p1)(int,int) = max;
    //定义并初始化一个指向min函数的指针
    int (*p2)(int,int) = min;
    //分别使用两个不同的函数指针作为参数调用func，并打印结果
    printf("The maximum of 3 and 5 is %d\n", func(3, 5, p1));
    printf("The minimum of 3 and 5 is %d\n", func(3, 5, p2));
    return 0;
}
```
## ##⏹️函数指针-调用函数比大小 

```c
#include<stdio.h>
int max(int x,int y)
{
	return (x>y?x:y);
 } 
 
 void main()
 {
	int a,b,c;
	int (*p)(int,int); 
	//定义一个函数指针，对函数的要求是该函数返回值是整型且参数为双整型 
	p=max;//使指针p指向函数首地址 
	scanf("%d,%d",&a,&b);
	c=(*p)(a,b);//c=max(a,b);  
	//这个读取p这个函数指针的地址，也就是max函数程序处，
	//和注释里写函数名的调用效果是等价的 
	printf("max=%d\n",c);
	 
	return 0; 
	 
 }
```
## ##⏹️函数指针-结合指针数组来进行多函数的调用

```c
#include<stdio.h>
int max(int x,int y) //正确问号，错误引号 
{	return(x>y?x:y);    } 
int min(int x,int y) // 
{	return(x>y?y:x);	} 
int add(int x,int y) // 
{	return(x+y);	   }

//这里来个全局指针数组 

int (*p[3])(int,int)={max,min,add};
//对指针数组进行初始化，一一对应三个函数的首地址 

int fun1(int x,int y,int n) 
//第三个参数直接表示第几个函数，传入可以直接作为指针数组下标 
{   
	int result; 
    result=(*p[n])(x,y); 
    //对这个指针进行读值，那就是调用对应三个函数中的一个， 
    return result;  
}

int fun2(int x,int y,int(*p)(int,int)) //第三参数可以看作一种工具 
//这里将函数作为参数，进行任意的传递，可以在函数里实现其他函数。 
{
	int result;
	result=(*p)(x,y);//这里就是在自定义函数里调用其他函数。 
	
	return result;
 } 
int main()
{
	int a,b;
	scanf("%d%d",&a,&b);
	printf("max=%d\nmin=%d\n",fun1(a,b,0),fun1(a,b,1));
	//别忘了数组首元素还是0 
	printf("a+b=%d",fun2(a,b,add));//直接写函数名，相当于传入函数首地址 
 
	return 0; 
 } 
```
