# ▶️小函数剥离封装
>	如果在自定函数里发现有通用的功能代码块,那么就可以封装成一个小函数
>例如通讯录中的DEl和SEARCH中就同时需要"查询"这一个代码块功能
>此时可以再自定一个查询的小函数来解决这些大函数之间的代码冗杂问题
>
# ▶️函数传参过多
>	如果一个函数需要传多个参数,不妨让这些参数成为结构体成员
>两个也可以用一个结构体囊括,这样传参就只用传一个囊括这些参数的结构体指针
>如果这些参数里有结构体也可以用一个大结构体囊括,此时就是结构体嵌套
>小结构体可以同其他变量一样作为大结构体的结构体成员,
>而这个小结构体里又可以囊括一些更加细分的成员

# ▶️函数功能常量化
>	指针在传参时,可以加上`const`进行常量化
>这样就从源头上避免了对指针所指变量值的修改和变动
>例如通讯录中的SEARCH只是单纯查询,并未修改传入的指针所指变量

# ▶️预处理的嵌套
>	自定头文件中是可以嵌套c常规头文件的 `<stdio.h> <string.h>`  等等
>这样就不需要再写一次`include`了,而是写那个封装好常规头文件的大头文件即可
>自定头文件中可以添加宏定义
>自定头文件中可以添加各种自定函数

# ▶️小函数功能局限化
>自定头文件中出现封装小函数的时候可以加上`static`
>此时该函数只用于头文件中自定函数之间的调用,避免了暴露在源文件中的被调用风险
>源文件要使用头文件自定函数时,也避免还要声明头文件自定函数里的小函数,造成声明冗杂

# ▶️枚举可视化
>`switch`的`case`语句中往往字面量1.2.3等等数字自变量无法直观的看出所要实现的功能
>可以通过枚举进行可视化操作,此时case后面就可以直接加上red.add.等直观的字面量
>[[STRUCTURE——结构体#枚举]]

# ▶️排序注意覆盖问题
>	浓缩一句话,从前往前,从后往后
>例如有一个人想置顶,那么后面的人会依次退下来
>此时不能从前面往后面依次退,此时会有覆盖问题
>应该让最后面的人先往后退,往前也同理
>按这个思路来就不需要太多的暂存变量`tmp`


# ▶️条件表达式和逗号表达式
> 	条件运算符 
> 	（条件）？（表达式2）：（表达式3）；
> 	（左值）= （条件）？（赋值运算1）：（赋值运算2）；
> 判断条件是否为真，为真则执行表达式2，否则执行表达式3
> 判断条件是否为真，为真则赋为表达式2的值，否则赋为表达式3的值
> 该三目运算可以用于赋值也可以用于语句执行

> 	逗号运算符
> 	（表达式1），（表达式2），（表达式n）；
> 表达式1执行，表达式2也执行，按顺序执行到表达式n；
> 整个逗号表达式的值是最后一个表达式的值；
> 该多目运算可用于赋值也可以用于语句执行

# ▶️字符输入时空格也会被吸收
>	`scanf("%c",&ch)`时
>如果输入空格,那么空格也会作为字符被吸收

# ▶️浮点型关于是否等于零的判断
>	`fabs（y）>1e-10` 判斷浮点型y不為0，為什麼不直接表示為`y!=0`
 如果這個 y 有別的作用，比如作為除數參與其他運算，由於 C 語言不支援無限精度計算，一個極小的非零數和零一樣可能導致異常的結果，因此需要排除這種情況

# ▶️else的嵌套
>	else内也可以嵌套

# ▶️文件操作函数的二进制输入输出
>	只有fread和fwrite函数才可以做到二进制的输入输出
>	其余文件指针操作函数都是文本的输入输出
>	注意,字符的二进制和文本是一样的,如"abcd"的二进制还是"abcd"
>	但是整型和浮点型的二进制和文本就不一样了

# ▶️文件操作函数的打开方式参数必须使用双引号
>	"w"而不是'w' ,单引号是字符,双引号是字符串
>	根据函数参数的格式要求,必须传入字符串,故必须都是双引号

# ▶️同类型的结构体可取等
> [[STRUCTURE——结构体#⏹️结构体初始化|代码块中的b1和b2两个结构体的赋值取等操作]]
>	注意,字符需要调用string库中的strcpy来进行copy

# ▶️位运算是指对数值的二进制位进行操作
>	C语言提供了六种位运算符，由于底层, 所以性能更优
>	<< 左移：将一个数的二进制位向左移动指定的位数，右边补0。
>	\>\> 右移：将一个数的二进制位向右移动指定的位数，左边补0或1（取决于符号）。 	 
>	\~ 按位取反：将一个数的每个二进制位取反，即0变1，1变0。
>	& 按位与：将两个数的对应二进制位进行逻辑与运算，都为1时结果为1，否则为0。
>	| 按位或：将两个数的对应二进制位进行逻辑或运算，都为0时结果为0，否则为1。
>	^ 按位异或：将两个数的对应二进制位进行逻辑异或运算，即相同为0，不同为1。

# ▶️结构体类型与结构体变量可同名
>	区别如同int类型和int型变量的区别
>	同时结构体成员可以与程序中的变量同名,他们代表不同的的对象,互不干扰

# ▶️简单语句的作用域问题
	变量的作用域可以分为文件作用域，函数作用域，块作用域和函数原型作用域。
	在if语句中定义的变量属于块作用域
	它的可见范围是从定义处到包含该定义的块的末尾。
	也就是说，这个变量只能在if语句里面使用，出了if语句就无效了。
# ▶️scanf进行多个字符串输入时候不要加符号
	不要写"scanf("%d,%d",&a,&b)""
	不要写"scanf("%d\n",&a)""
# ▶️scanf有返回值
	1.  函数返回成功读取并解析的项目数，如果读取失败则返回 `EOF`（在 `<stdio.h>` 头文件中定义的常量，表示文件结束符）。
# ▶️指针(地址)本质就是整型变量
	1.  语法简洁明了。指针变量可以在语法上和其他变量一样使用，而不需要额外的转换和操作。
	2.  程序的可读性更好。使用指针变量可以更加清晰地表达程序员的意图，让代码更加易于理解和维护。
	3.  功能更加强大。指针变量可以用来实现一些高级的功能，如动态内存分配、链表、树等数据结构。
	4.  更高的灵活性。指针变量可以被用来处理多种数据类型，而整型变量则只能用来处理整数类型。
# ▶️long和short
	1.  `short` 和 `long` 是整数数据类型，用于存储整数，而 `unsigned short` 和 `unsigned long` 则是无符号整数数据类型，也用于存储整数，但是不能存储负数。
	2.  `short` 通常使用 2 个字节（16 位）来存储，其范围为 -32768 到 32767。`long` 通常使用 4 个字节（32 位）来存储，其范围为 -2147483648 到 2147483647。而 `unsigned short` 和 `unsigned long` 的范围分别为 0 到 65535 和 0 到 4294967295。
	3.  在使用这些类型时，我们需要注意其数据范围，以免出现溢出的情况。
# ▶️字符串可以存储转义字符
	是的，字符串可以存储转义字符，包括像`\n`这样的特殊字符。转义字符是一种表示特殊字符的方式，通常以反斜杠`\`开头，后跟一个或多个字符。在字符串中，如果您想要包含换行符，则可以使用`\n`。当您在字符串中使用`\n`时，它将被解释为一个换行符，并在输出时产生换行。
# ▶️不应该让函数返回局部变量的指针
	这个局部变量只能在函数内部使用,函数调用结束之后就会回收了,此时你返回该地址,那该地址所指的区域已经没有值了
	当然,函数内部申请的内存空间的基地址是完全可以返回的,这片内存空间必须通过特殊语句`free`或者c++中的`delete`才能够释放,而不会被函数自己回收,
# ▶️回调函数就是通过函数指针调用的函数
	如果把函数的指针 (地址)作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，这个被调用的函数就称作回调函数。回调函数是在特定的事件或条件发生时由另外一方调用，用于响应该事件或条件。
# ▶️局部变量屏蔽全局变量
	在函数内部定义的变量，其作用域仅限于函数内部，这样的变量称为局部变量。全局变量则是定义于函数之外，作用域为整个源程序
	局部函数可以和全局变量同名,但是局部变量会屏蔽全局变量
# ▶️静态变量的生命周期和源程序相同
	非静态局部变量：非静态的局部变量会在函数结束之后消失,但是静态局部变量在函数结束之后仍然存在,只是在函数外部无法调用,作用域仍然在函数内部
	当一个源文件由多个文件组成时,非静态的全局变量作用域为整个源程序,但是静态全局变量的作用域仅限于定义该变量的源文件.
# ▶️数组成员操作参与宏定义
```
#include <stdio.h>

#define GET_VALUE(arr, index) arr[index]
#define SET_VALUE(arr, index, value) arr[index] = value
#define COMPARE(arr1, index1, arr2, index2) (arr1[index1] == arr2[index2])

int main() {
    int arr1[] = {1, 2, 3, 4, 5};
    int arr2[] = {6, 7, 8, 9, 10};

    // 使用宏定义获取数组成员的值
    int value = GET_VALUE(arr1, 2);
    printf("Value: %d\n", value);

    // 使用宏定义设置数组成员的值
    SET_VALUE(arr2, 3, 100);
    printf("Updated value: %d\n", arr2[3]);

    // 使用宏定义比较数组成员的值
    if (COMPARE(arr1, 1, arr2, 1)) {
        printf("Values are equal\n");
    } else {
        printf("Values are not equal\n");
    }

    return 0;
}
```
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
# ▶️
