

https://blog.csdn.net/qq_52357217/article/details/128621060

https://blog.csdn.net/qq_52357217/article/details/128622209

## 基本概念

**得瑟得瑟**
 
 *得瑟得瑟*



 #### 图形化和命令行的概念
图形化（Graphical User Interface，GUI）和命令行（Command Line Interface，CLI）是计算机用户与计算机系统进行交互的两种不同方式。

1. **图形化（GUI）：**
   - **定义：** GUI是通过图形元素，如图标、窗口、菜单和按钮等，来实现用户与计算机系统交互的方式。
   - **特点：** 用户通过鼠标、键盘或触摸屏等输入设备在屏幕上直观地点击、拖动和操作图形元素。GUI通常提供了直观的可视化界面，对于非专业用户更加友好。
   - **优点：** 易学易用，用户无需记忆复杂的命令，可以通过直观的图形界面完成各种任务。适用于桌面应用程序、图形设计等。

2. **命令行（CLI）：**
   - **定义：** CLI是通过文本命令来与计算机系统进行交互的方式。用户通过键盘输入命令，系统返回相应的文本输出。
   - **特点：** 用户需要记忆和输入一系列的命令，每个命令通常由指令和参数组成。CLI通常更加灵活，允许用户通过组合不同的命令完成复杂的任务。
   - **优点：** 对于熟练的用户，CLI可以更高效，尤其在自动化脚本和批处理任务方面更具优势。适用于服务器管理、编程开发等。

#### 分区

Linux的分区方案可以根据你的需求和系统用途而有所不同，但通常建议考虑以下几个关键分区：
1. **（/）根分区：**
   - 这是Linux系统的根目录，包含所有系统文件。建议将其分配给足够大的空间，通常至少20GB，具体取决于你的系统和软件需求。
2. **swap交换分区：**
   - 交换分区用于支持系统的虚拟内存。其大小通常是物理RAM的1.5倍到2倍。如果你有足够的RAM，也可以考虑不分配交换分区。
3. **/home分区：**
   - /home目录包含用户的个人文件和设置。将其分配给足够大的空间，以容纳用户数据。这可以使系统恢复或重新安装时保留用户数据。
4. **/boot分区：**
   - /boot包含启动加载程序和内核文件。通常，2GB的空间就足够了。在UEFI系统中，/boot/efi分区可能是必需的。
5. **/var分区：**
   - /var目录包含系统运行时生成的可变数据，如日志文件、数据库文件等。分配足够的空间以防止/var目录耗尽空间导致系统问题。
6. **/tmp分区：**
   - /tmp用于存储临时文件。分配足够的空间，并定期清理以防止空间不足。
7. **/opt分区：**
   - /opt通常用于安装第三方软件。如果你计划安装大量的第三方应用程序，可以考虑将/opt分区设置为较大的空间。
8. **/usr分区：**
   - /usr包含系统软件和用户不经常修改的数据。将其分配给足够大的空间，特别是如果你计划安装大量软件。
总体而言，分区方案应该根据你的具体需求进行调整。例如，如果你有多个硬盘，可以考虑将某些目录（如/home或/var）放在单独的硬盘上以提高性能。重要的是在设计分区方案时考虑到系统的未来扩展和维护。

| 分区类型 | 一般大小             | 设备类型 | 文件系统 |
| -------- | -------------------- | -------- | -------- |
| Boot     | 1GB                  | 标准分区 | ext4     |
| Swap     | 2GB                  | 标准分区 | swap     |
| Root     | 分区后余下所有的空间 | 标准分区 | ext4     |

#### 网络连接的三种方式

- 桥接相当于跟你主机一样有ip地址，但是在本机的环境中占用一个ip地址，如果本机的环境有多个设备，可能会造成ip不够用的情况
- NAT模式相当于中间者，给你路由出去

![[Pasted image 20231130210958.png]]

#### 虚拟机克隆,迁移和删除

- 如果已经安装了系统， 没必要重新安装，只需要克隆即可：
	1. 直接从安装盘里拷贝整一份系统文件到别的盘符即可,这种克隆的文件可以直接移植到另一个电脑
	2. 使用vm的克隆功能，注意选择‘创建完整克隆(深克隆)’，而非“创建链接克隆(浅克隆)”，，且先关闭Linux系统
- 虚拟机的本质就是文件,其迁移和删除是非常简单的文件操作
	1. 可以直接迁移整个系统(cut or copy)
	2. 使用vm的移除功能

#### 虚拟机快照

虚拟机快照是虚拟化环境中的一种重要功能，允许用户在虚拟机运行时捕获虚拟机的当前状态，并保存为一个点。这个点可以在以后的任何时候用来还原虚拟机到先前的状态。(类似游戏中的存档回档机制),但是要注意快照是会占用内存的,不要滥用

1. 安装好系统之后,先做一个快照A
2. 进入到系统之后.创建一个文件夹,再保存一个快照
3. 回到系统刚刚安装好的状态,即快照A
4. 试试看,是否还能再次回到快照B

#### vmtools工具

- 可以设置一个windows和linux的共享文件夹,使双方对该文件夹都能进行读写操作

	1. 进入系统后点击vm菜单-> install vmware tools
	2. 系统内出现一个VMware Tools的光碟,光碟内有vmtool的安装包 `xxx.tar.gz`
	3. 手动将将这个安装包拷贝到 `/opt`(这个在Home里好像)
	4. 通过终端进入到该目录下 `cd /opt/`
	5. 使用解压命令`tar -zxvf xxx.tar.gz` 继续进入到该目录下的解压文件夹 `cd /vm...`
	6. 直接使用安装命令 `./vmware-install.pl`   
	7. 全部使用默认设置, 到最后一步,如果vm本身自带vmtools,后面的安装步骤出现`uninstall`的字样,要选择no
	8. 注意安装vmtools需要有gcc编译器 可以通过指令查看 `gcc -v`

- 设置共享文件夹
	
	1. 在需要设置共享文件夹的虚拟机上点击右键
	2. 点击 设置 – 选项 – 共享文件夹 – 总是启用 – 添加共享文件夹目录 – 点击确定

- 怎么在Linux下读取共享文件？
	
	1. 点击主文件夹 – 其他位置 – 计算机 – mnt文件夹 – hgfs文件夹 – 当前的共享文件夹

#### 文件目录
- Linux的世界里,一切皆文件(cpu等等硬件驱动都有对应文件)
- Linux 的文件系统是采用层级式的树状目录结构，
![[Pasted image 20231201144848.png]]

0. <mark style="background: #FFB8EBA6;">/ [根]  ~ [家] </mark> 
	最上层是 根目录 “/”，然后在此目录下再创建其他的目录
	当你在命令行或脚本中使用 `~` 时，系统会将其解释为当前用户的家目录。
	使用 `~` 表示用户家目录时，是一种相对路径，相对于当前用户的位置。而 `/` 表示根目录时，是一种绝对路径，是文件系统的起始点。
1. <mark style="background: #FFB8EBA6;">/bin[命令区]</mark> (常用) (/usr/bin、/usr/local/bin)
	是 Binary 的缩写，这个目录存放着最经常使用的命令
2. <mark style="background: #FFB8EBA6;">/sbin[管理员程序]</mark> (/usr/sbin、/usr/local/sbin)
	s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序
3. <mark style="background: #FFB8EBA6;">/home[主界面]</mark> (常用)
	存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录是以用户的账号命名
	使用命令`useradd [username]`可以添加用户,此时会多一个用户文件
	使用命令`userdel -r [username]` 可以删除用户, 其用户文件也会删除
1. <mark style="background: #FFB8EBA6;">/root[管理员]</mark> (常用)
	该目录为系统管理员，也称作超级权限者的用户主目录
5. <mark style="background: #FFB8EBA6;">/lib[共享链接库]</mark> 
	系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都都需要用到这些共享库
6. <mark style="background: #FFB8EBA6;">/lost + found[找回] </mark>
	这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件
7. <mark style="background: #FFB8EBA6;">/etc[预留配置文件]</mark> (常用)
	所有的系统管理所需要的配置文件和子目录，比如安装 mysql 数据库 my.conf
8. <mark style="background: #FFB8EBA6;">/usr[用户管理]</mark> (常用) 
	这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与Windows下的 program files目录
9. <mark style="background: #FFB8EBA6;">/boot[启动文件]</mark> (常用) (不能碰)
	存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件
10. <mark style="background: #FFB8EBA6;">/proc[系统进程]</mark> (不能碰) 
	这个目录是一个虚拟目录，它是系统内存的映射，访问这个目录来获取系统信息
11. <mark style="background: #FFB8EBA6;">/srv[服务器数据]</mark> (不能碰) 
	service缩写，该目录存放一些服务启动之后需要提取的数据
12. <mark style="background: #FFB8EBA6;">/sys[系统文件区]</mark> (不能碰) 
	这是Linux 2.6 内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs
13. <mark style="background: #FFB8EBA6;">/tmp[缓存区]</mark> 
	这个目录是用来存放一些临时文件的
14. <mark style="background: #FFB8EBA6;">/dev[硬件区]</mark> 
	类似于Windows的设备管理器，把所有的硬件用文件的形式存储
15. <mark style="background: #FFB8EBA6;">/media[自动识别设备区]</mark> (常用) 
	Linux 系统会自动识别一些设备，例如 U盘、光驱等等，当识别后，Linux会把识别的设备挂载到这个目录下
16. <mark style="background: #FFB8EBA6;">/mnt[挂载其余文件系统]</mark> (常用)
	系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载到 /mnt 上，然后进入该目录就可以直接查看里面的内容了
	(/mnt/hgfs/ 放在hgfs)
17. <mark style="background: #FFB8EBA6;">/opt[下载目录]</mark> 
	这是给主机额外安装软件所存放的目录,如安装 ORACLE数据库就可以放到该目录下，默认为空
18. <mark style="background: #FFB8EBA6;">/usr/local[安装目录]</mark> (常用)
	这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码的方式安装程序
19. <mark style="background: #FFB8EBA6;">/var[可修改杂项]</mark> (常用)
	这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件(log)
20. <mark style="background: #FFB8EBA6;">/selinux </mark>
	SELinux 是一种安全子系统(security-enhance linux)，他能控制程序只能访问特定文件，有三种工作模式，可以自行设置

```plaintext
/
|-- /bin
|   |-- ls
|   |-- cp
|   |-- mv
|   |-- ...
|-- /sbin
|   |-- init
|   |-- fsck
|   |-- ...
|-- /home
|   |-- /user1
|   |   |-- Documents
|   |   |-- Downloads
|   |   |-- ...
|   |-- /user2
|   |   |-- Documents
|   |   |-- Downloads
|   |   |-- ...
|-- /root
|   |-- Documents
|   |-- Downloads
|   |-- ...
|-- /lib
|   |-- lib1.so
|   |-- lib2.so
|   |-- ...
|-- /lost+found
|-- /etc
|   |-- /apache
|   |-- /mysql
|   |-- ...
|-- /usr
|   |-- /bin
|   |   |-- userapp1
|   |   |-- userapp2
|   |   |-- ...
|   |-- /sbin
|   |   |-- usersysapp1
|   |   |-- usersysapp2
|   |   |-- ...
|   |-- /local
|   |   |-- /bin
|   |   |-- /sbin
|   |   |-- ...
|   |-- ...
|-- /boot
|   |-- vmlinuz
|   |-- initrd
|   |-- ...
|-- /proc
|   |-- cpuinfo
|   |-- meminfo
|   |-- ...
|-- /srv
|   |-- service1
|   |-- service2
|   |-- ...
|-- /sys
|   |-- /kernel
|   |-- /devices
|   |-- ...
|-- /tmp
|-- /dev
|   |-- /sda
|   |-- /tty1
|   |-- ...
|-- /media
|   |-- /usb
|       |-- ...
|-- /mnt
|   |-- /external
|       |-- ...
|-- /opt
|   |-- /oracle
|       |-- ...
|-- /usr/local
|   |-- /bin
|   |-- /sbin
|   |-- ...
|-- /var
|   |-- /log
|   |   |-- system.log
|   |   |-- app.log
|   |   |-- ...
|   |-- /spool
|   |   |-- cron
|   |   |-- ...
|   |-- ...
|-- /selinux
|   |-- config
|   |-- policy
|   |-- ...

```

#### 远程登录和远程文件传输
![[Pasted image 20231201203412.png]]


- Linux服务器是开发小组共享，正式上线的项目是运行在公网，因此程序员需要远程登录到Linux进行项目管理或者开发，画出简单的网络拓扑示意图之后就可以远程办公了
- 远程登录客户端有 Xshell6、Xftp6，我们学习使用Xshell和Xftp6，其他远程工具大同小异finalshell , xshell , MobaXterm
```bash

(Linux终端输入)
 ifconfig  用于查看Linux的公网IP(那个inet后面的192.168.179.131)

(Windows终端输入)
> ping [IP地址] 用于检查两台设备的网络是否畅通
```

- 首先进行IP的获取以及PING测试，Xshell和Xftp配置完毕后点击确定，在左侧的会话管理器中双击刚才添加的Linux主机
- 此时窗口中会弹出选项，选择一次性接收(类似登录的不保存账号密码) 或 接受并保存(类似登录的记住账号密码)
- 注意：Xftp 中文显示乱码问题，点击左上角的属性，点击选项，把编码调成UTF8即可

## 基本操作
#### vi 和 vim 编辑器
![[Pasted image 20231203155444.png]]
- Linux系统会内置vi文本编辑器
- Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用

1. <mark style="background: #ADCCFFA6;">正常模式</mark>
	以vim打开一个档案就直接进入一般模式了（这是默认的模式）
	在这个模式中，你可以使用〖上下左右〗按键来移动光标，你可以使用〖删除字符」或〖删除整行〗来处理档案内容，也可以使用〖复制、粘贴〗来处理你的文件数据

2. <mark style="background: #ADCCFFA6;">插入模式</mark>
	按下i、I、o、O、a、A、r、R等任何一个字母之后才会进入编辑模式，一般来说按i即可

3. <mark style="background: #ADCCFFA6;">命令行模式</mark>
	在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作则是在此模式中达成的

```vim
<一般模式>

[yy] 拷贝当前行
[p] 粘贴
[yyp] 拷贝当前行并粘贴：
[5yyp] 拷贝当前行向下的5行并粘贴：
[dd] 删除当前行 
[5dd] 删除当前行向下的5行
[G] 定位到最末尾行
[20G] 定位到20行 (注意输入的时候是看不到数字的,因为不在命令行)
[gg] 定位到首行
[u] 撤销操作

<命令行模式>

[:/keyword] '/'加关键字，回车查找，输入n就是查找下一个
[:set nu] [:set nonu] 显示行号和不显示行号

```
![[Pasted image 20231203163647.png]]



#### 关机重启
| 命令            | 作用                   |
| --------------- | ---------------------- |
| `shutdown -h now` = `halt` | 立刻进行关机           |
| `shutdown -h 1 `  | 1分钟后关机            |
| `shutdown -r now ` = `reboot`| 现在重新启动计算机     |
|` sync`            | 把内存的数据同步到磁盘 |
注意:不管是重启系统还闭系统，首先要运行sync命令，把内存中的数据写到磁盘中
目前的 shutdown/reboot/halt 等命令均已经在关机前进行了sync 但是需要养成这个习惯以防万一

#### 用户登录和注销

<mark style="background: #FF5582A6;">su - [username]</mark> 切换成用户身份 
<mark style="background: #FF5582A6;">su -</mark> 或者 <mark style="background: #FF5582A6;">su - root</mark> 均可以切换成系统管理员,获得最高权限
- 登录时尽量少用root帐号登录，因为它是系统管理员，最大的权限，避免操作失误。
- 可以利用普通用户登录，登录后再用命令来切换成系统管理员身份
<mark style="background: #FF5582A6;">logout</mark> 注销用户
- 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要
- 当需要返回到原来用户时，使用 exit/logout 指令
```bash
-----由root用户切换至普通用户-----
[root@SanxCentOS7 home] su - ben

-----由普通用户切换到root用户-----
[ben@SanxCentOS7 ~] su - root
#	密码：
#	上一次登录：五 10月  7 15:44:34 CST 2022从 192.168.174.1pts/1 上

-----由root用户注销至普通用户-----
[root@SanxCentOS7 ~] logout

-----由普通用户注销至退出系统-----
[ben@SanxCentOS7 ~] exit
#	登出
[root@SanxCentOS7 home] logout
#	Connection closed.
#	Disconnected from remote host(192.168.174.129[CentOS7_1]) at 15:58:29.
#	Type `help' to learn how to use Xshell prompt.
[C:\~]$ 
```

<mark style="background: #FF5582A6;">useradd [username]</mark>  添加新用户
- 当创建用户成功后，会自动的创建和用户同名的家目录(默认目录在/home/xxx),
```bash

[root@odddouglas ~] cd /
[root@odddouglas /] ls
#	bin  boot  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@odddouglas /] cd home
[root@odddouglas home] ls
#	iota
[root@odddouglas home] useradd kappa
[root@odddouglas home] ls
#	iota  kappa

```

<mark style="background: #FF5582A6;">usereadd -d [PATH] [new username]</mark> 给新创建的用户指定家目录
```bash
[root@SanxCentOS7 home] useradd -d /home/test xiaohong
[root@SanxCentOS7 home] ls
#	iota  kappa  test
```

<mark style="background: #FF5582A6;">passwd [username]</mark> 修改账户密码
- 如果没有写用户名，那么默认的就是修改当前账户的密码
- 输入密码的时候是看不到的请注意
```bash
[root@odddouglas home] passwd kappa
#	Changing password for user kappa.
#	New password: 
#	Retype new password: 
#	passwd: all authentication tokens updated successfully.

```


<mark style="background: #FF5582A6;">userdel [username]</mark> 这个命令并不会删除家目录，它是直接保留在家目录中的
<mark style="background: #FF5582A6;">userdel -r [username] </mark> 这个命令会直接删除家目录下这个用户的所有文件，谨慎执行
```bash
[root@SanxCentOS7 home] userdel iota
[root@SanxCentOS7 home] ls
#	iota kappa  test 
------------------------------------
[root@SanxCentOS7 ~]# cd /home
[root@SanxCentOS7 home] ls
#	iota kappa test
[root@SanxCentOS7 home] userdel -r iota
[root@SanxCentOS7 home] ls
#	kappa  test
------------------------------------
```

<mark style="background: #FF5582A6;">id [username] </mark> 查询用户信息指令
<mark style="background: #FF5582A6;">whoami</mark> 查询当前用户
```bash
[root@odddouglas home] id iota
#	uid=1000(iota) gid=1000(iota) groups=1000(iota)
[root@odddouglas home] id root
#	uid=0(root) gid=0(root) groups=0(root)
[root@odddouglas home] id kappa
#	uid=1001(kappa) gid=1001(kappa) groups=1001(kappa)
[root@odddouglas ~] whoami
#	root
```

#### 组管理

- 类似与角色，系统可以对有 共性/权限 的多个用户进行统一的管理
	uid=用户ID(用户名) gid=主要组ID(主要组名) 组=附加组ID(附加组名)

<mark style="background: #FF5582A6;">groupadd [groupname]</mark> 新增组
<mark style="background: #FF5582A6;">groupdel [groupname]</mark> 删除组
<mark style="background: #FF5582A6;">useradd -g [groupname] [username] </mark> 增加已分组的用户
- 特别的，如果添加一个用户而没有指定组，那么系统会自动把该用户添加到与该用户同名的组里

```bash
[root@SanxCentOS7 ~] groupadd qingshi
[root@SanxCentOS7 ~] groupdel qingshi
[root@SanxCentOS7 ~] groupadd qingshi
[root@SanxCentOS7 ~] useradd -g qingshi liuwendi
[root@SanxCentOS7 ~] id liuwendi
#	uid=1004(liuwendi) gid=1004(qingshi) 组=1004(qingshi)


```

<mark style="background: #FF5582A6;">usermod -g [new groupname] [username]</mark> 修改用户组
```bash

[root@SanxCentOS7 ~] id iota
#	uid=1004(liuwendi) gid=1004(qingshi) group=1004(qingshi)

-------------------------------------------

[root@SanxCentOS7 ~] groupadd daibiao
[root@SanxCentOS7 ~] usermod -g daibiao liuwendi
[root@SanxCentOS7 ~] id liuwendi
#	uid=1004(liuwendi) gid=1005(daibiao) group=1005(daibiao)

```

#### 用户和组的相关文件
```plaintext
|-- /etc
|   |-- /passwd
|   |-- /shadow
|   |-- /group
```
<mark style="background: #FFB8EBA6;">/etc/passwd </mark> 用户（user）的配置文件，记录用户的各种信息
	每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
```Linux
john:x:1000:1000:John Doe:/home/john:/bin/bash

- 用户名是 `john`。
- 口令字段为 'x' 或 '*'。
- 用户标识号（UID）为 1000。
- 组标识号（GID）为 1000。
- 注释性描述是 `John Doe`。
- 主目录是 `/home/john`。
- 登录 Shell 是 `/bin/bash`，表示用户在登录后使用 Bash Shell。
```
<mark style="background: #FFB8EBA6;">/etc/shadow </mark> 口令的配置文件
	每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
```Linux
john:$6$4L.:18866:0:99999:7:::

1. **登录名（Login Name）：** `john`
2. **加密口令（Encrypted Password）：** `$6$4L.` (一般很长,这里写短一点而已)
3. **最后一次修改时间（Last Password Change Time）：** `18866`
4. **最小时间间隔（Minimum Password Age）：** `0`
5. **最大时间间隔（Maximum Password Age）：** `99999`
6. **警告时间（Password Warning Period）：** `7`
7. **不活动时间（Inactive Period）：** ``
8. **失效时间（Account Expiration Time）：** ``
9. **标志（Flag）：** `7`
```
<mark style="background: #FFB8EBA6;">/etc/group</mark> 组 (group) 的配置文件，记录 Linux 包含的组信息
	每行的含义：组名:口令:组标识号:组内用户列表
```Linux
john:x:1000:john

1. **组名（Group Name）：** `john`
2. **口令（Password）：** `x`（在 /etc/group 中密码字段不再使用，通常被设置为 'x' 或 '*'）
3. **组标识号（Group ID）：** `1000`
4. **组内用户列表（Group Members）：** `john`（表示该组中包含用户 `john`）
```
#### 关于登录shell

1. **Bash（Bourne Again SHell）：**
    
Bash 是大多数 Linux 系统的默认 shell。它是 Bourne Shell 的增强版本，具有许多扩展功能，包括命令历史、自动补全等。大多数脚本和命令行环境中都可以使用 Bash。

2. **Zsh（Z Shell）：**
    
Zsh 是一个功能强大的 shell，具有高级的自动补全、主题和插件系统。它提供了用户友好的命令行体验，并在终端中显示丰富的信息。Zsh 在用户社区中越来越受欢迎。

3. **Fish Shell：**
    
Fish Shell 是一种用户友好的 shell，它设计得更为现代化，并且具有直观的自动补全和语法高亮功能。Fish Shell 提供了一些独特的语法和功能，使得命令行更易于使用。

4. **Dash Shell：**
    
Dash 是一个轻量级的 POSIX 兼容 shell，通常用作 `/bin/sh` 的实现。它专注于速度和低系统资源使用，因此在一些系统上作为默认的 `/bin/sh`。

5. **KornShell（ksh）：**
    
KornShell 是一种扩展的 Bourne Shell，具有更多的特性，包括数组、关联数组、参数扩展等。KornShell 在商业环境中经常被使用。

#### 指定运行级别

运行级别说明
0：关机
1：单用户〖找回丢失密码〗
2：多用户状态没有网络服务(终端)
3：多用户状态有网络服务(终端)
4：系统未使用保留给用户(终端)
5：图形界面(默认)
6：系统重启
常用运行级别是3和5，也可以指定默认运行级别，后面演示

<mark style="background: #FF5582A6;">init [num]</mark> 用于指定运行级别
<mark style="background: #FF5582A6;">systemctl get-default</mark> 查看当前的默认运行级别
<mark style="background: #FF5582A6;">systemctl set-default [TARGET.target]</mark> 设置默认的运行级别
	multi-user.target : 多用户状态有网络服务 (analogous to runlevel 3)
	graphical.target : 图形界面(默认) (analogous to runlevel 5)

#### 找回root密码
1. 在开机界面输入 `e`
2. 进入编辑界面，使用键盘上的上下键把光标往下移动，找到以`Linux16`开头内容所在的行数”，在行的最后面输入：<mark style="background: #FFF3A3A6;">init=/bin/sh</mark>
![[Pasted image 20231203210724.png]]
3. 接着，输入完成后，直接按快捷键 `Ctrl+x` 进入 单用户模式
![[Pasted image 20231203210739.png]]
4. 接着，在光标闪烁的位置中输入：<mark style="background: #FFF3A3A6;">mount -o remount,rw /</mark>（注意：各个单词间有空格,逗号左右无空格）完成后按键盘的回车键(`Enter`) 不要忘记最末尾的斜杆 `/`
![[Pasted image 20231203210801.png]]
5. 在新的一行最后面输入：<mark style="background: #FFF3A3A6;">passwd</mark>，完成后按键盘的回车键(`Enter`）输入密码，然后再次确认密码即可密码修改成功后，会显示passwd…的样式，说明密码修改成功
![[Pasted image 20231203210812.png]]
6. 接着，在鼠标闪烁的位置中（最后一行中）输入：<mark style="background: #FFF3A3A6;">touch /.autorelabel</mark>（注意：touch后面有一个空格）完成后按键盘的回车键(`Enter`)
![[Pasted image 20231203210838.png]]
7. 继续在光标闪烁的位置中，输入：<mark style="background: #FFF3A3A6;">exec /sbm/init</mark>（注意：exec后面有一个空格），完成后按键盘的回车键 (`Enter`)，等待系统自动修改密码，完成后，系统会自动重启：新的密码生效了
![[Pasted image 20231203210851.png]]

## 指令学习
#### 帮助指令

<mark style="background: #FF5582A6;">man [cmd or cfg]</mark> 获得命令或配置文件的帮助信息
![[Pasted image 20231203212026.png]]

<mark style="background: #FF5582A6;">help [cmd]</mark> 获得shell内置命令的帮助信息
![[Pasted image 20231203214017.png]]

## 文件目录类

#### 查看所在目录
<mark style="background: #FF5582A6;">pwd</mark> 显示当前工作目录的绝对路径
```bash
[root@SanxCentOS7 ~] cd /home
[root@SanxCentOS7 home] ls
#	ben  liuwendi  sanx  test

[root@SanxCentOS7 home] cd ben/
[root@SanxCentOS7 ben] vim a.txt
[root@SanxCentOS7 ben] pwd
#	/home/ben

```  

#### 查看目录文件清单
<mark style="background: #FF5582A6;">ls [option] [dir or file]</mark> 列出文件 (list) (中括号参数不填的话就默认列出当前列表)
`[option]`：
<mark style="background: #FFF3A3A6;">-a</mark>：显示当前所有的文件和目录，包括隐藏的(隐藏文件是以 . 开头的文件)
<mark style="background: #FFF3A3A6;">-l</mark>：以列表的方式来显示信息
<mark style="background: #FFF3A3A6;">-lh</mark>：按照人类的理解来显示该目录下文件的详细信息(这个h可以把原先按字节显示的数据以缩写显示)
<mark style="background: #FFF3A3A6;">-la</mark>: 选项可以组合使用，

#### 切换目录
<mark style="background: #FF5582A6;">cd [dir]</mark> 切换到指定目录 (change directory)
`[dir]`:
<mark style="background: #FFF3A3A6;">cd ~</mark> 或者 <mark style="background: #FFF3A3A6;">cd:</mark> 回到自己的家目录(root用户就回到/root, iota用户就回到/home或者/home/iota)
<mark style="background: #FFF3A3A6;">cd ..</mark> 回到当前目录的上一级目录(根目录的上一级还是根目录) 
<mark style="background: #FFF3A3A6;">cd /root</mark> 绝对路径的命令, 切换到 `root` 目录
<mark style="background: #FFF3A3A6;">cd ../../root/</mark>  相对路径的命令，表示将当前工作目录切换到上两级目录的 `root` 目录

1. **绝对路径：**
    - 绝对路径是一个完整的路径，从文件系统的根目录开始一直指向目标文件或目录的路径。
    - 以斜杠 `/` 开头，例如 `/home/user/documents/file.txt`。
    - 优点是路径非常明确，无论当前工作目录在哪里，都能准确定位文件或目录。
2. **相对路径：**
    - 相对路径是相对于当前工作目录的路径，描述如何从当前位置到达目标文件或目录。
    - 不以斜杠 `/` 开头，例如 `documents/file.txt`。
    - 优点是相对路径更为简洁，但需要考虑当前工作目录的影响。

#### 创建文件和目录
<mark style="background: #FF5582A6;">touch [file]</mark> 用于创建空文件
```bash
[root@SanxCentOS7 home] ls
#	ben  liuwendi  sanx  test
[root@SanxCentOS7 home] touch hello.txt
[root@SanxCentOS7 home] ls
#	ben  hello.txt  liuwendi  sanx  test
```

<mark style="background: #FF5582A6;">mkdir [option] [dir]</mark> 用于创建目录 (make directory)
`[option]`
<mark style="background: #FFF3A3A6;">-p</mark>: 创建多级目录
`[dir]`
<mark style="background: #FFF3A3A6;">mkdir new_directory
</mark>如果你想在当前工作目录下创建一个名为新目录，可以使用相对路径
<mark style="background: #FFF3A3A6;">mkdir /parent_directory/new_directory</mark> 指定路径下创建一个名为新目录，可以使用绝对路径：
<mark style="background: #FFF3A3A6;">mkdir -p /first_directory/second_directory</mark> 绝对路径的方式创建多个新目录

```bash
-----创建单个目录-----
[root@SanxCentOS7 ~] mkdir /home/dog
[root@SanxCentOS7 ~] cd /home
[root@SanxCentOS7 home] ls
#	ben  dog  liuwendi  sanx  test

-----尝试创建多级目录-----
[root@SanxCentOS7 home]# mkdir /home/animal/tiger
#	mkdir: 无法创建目录"/home/animal/dog": 没有那个文件或目录


-----正确的创建多级目录的方法-----
[root@SanxCentOS7 home] mkdir -p /home/animal/tiger
[root@SanxCentOS7 home] ls
#	animal  ben  dog  liuwendi  sanx  test

[root@SanxCentOS7 home] cd animal/
[root@SanxCentOS7 animal] ls
#	tiger
```

#### 删除空目录
<mark style="background: #FF5582A6;">rmdir [option] [empty dir] </mark> 删除空目录(如果目录下有内容时是无法删除的)
- 如果需要删除非空目录，需要使用 <mark style="background: #FFF3A3A6;">rm -rf [dir]</mark>
```bash
-----原本的目录结构-----
[root@SanxCentOS7 home] ls
#	animal  ben  dog  liuwendi  sanx  test

-----删除一个目录-----
[root@SanxCentOS7 home] rmdir /home/dog
[root@SanxCentOS7 home] ls
#	animal  ben  liuwendi  sanx  test

-----删除多个目录-----
[root@SanxCentOS7 home] rmdir /home/animal/
#	rmdir: 删除 "/home/animal/" 失败: 目录非空
[root@SanxCentOS7 home] rm -rf /home/animal/
[root@SanxCentOS7 home] ls
#	ben  liuwendi  sanx  test
```

#### 拷贝目录
<mark style="background: #FF5582A6;">cp [option] [source] [dest]</mark> 拷贝目标文件(source)到指定目录(destination)
`[option]
<mark style="background: #FFF3A3A6;">-r</mark> 递归复制整个文件夹
<mark style="background: #FFF3A3A6;">\cp -r [source] [dest]</mark> 指令前加一个`\`(在指定目录有重复文件时)强制覆盖而不进行询问
```bash
-----案例1：将/home/hello.txt 拷贝到 /home/bbb/hello.txt-----
[root@SanxCentOS7 home] mkdir /home/bbb
[root@SanxCentOS7 home] ls
	bbb  ben  hello.txt  liuwendi  sanx  test
[root@SanxCentOS7 home] cp hello.txt bbb/
[root@SanxCentOS7 home] ls
	bbb  ben  hello.txt  liuwendi  sanx  test
[root@SanxCentOS7 home] cd bbb/
[root@SanxCentOS7 bbb] ls
	hello.txt

-----案例2：递归复制整个文件夹 将/home/bbb整个目录，拷贝到/opt下-----
[root@SanxCentOS7 bbb] touch hello2.txt 
[root@SanxCentOS7 bbb] ls
#	hello2.txt  hello.txt
[root@SanxCentOS7 bbb] cd /home
[root@SanxCentOS7 home] cp -r /home/bbb /opt/
#	bbb  ben  hello.txt  liuwendi  sanx  test
[root@SanxCentOS7 home] cd /opt/
[root@SanxCentOS7 opt] ls
#	bbb  rh
[root@SanxCentOS7 opt] cd bbb/
[root@SanxCentOS7 bbb] ls
#	hello2.txt  hello.txt
[root@SanxCentOS7 bbb] pwd
#	/opt/bbb

-----强制覆盖文件且不提示，普通指令过于繁琐，需要询问每一个文件是否需要覆盖-----
[root@SanxCentOS7 bbb] cp -r /home/bbb /opt/
#cp：是否覆盖"/opt/bbb/hello.txt"? y
#cp：是否覆盖"/opt/bbb/hello2.txt"? y

#加入 "\" 后 就直接覆盖不会再询问了
[root@SanxCentOS7 bbb] \cp -r /home/bbb /opt/

```

#### 删除非空文件和目录
<mark style="background: #FF5582A6;">rm [option] [dir]</mark> 移除文件或目录(一般 rm 指令后跟的是绝对路径，如果要删除的文件或目录就在当前的工作目录，那么可以直接写文件的名字删除) (不带选项参数那就是单删) (注意删目录的时候末尾不要加`/`)
`[option]`
<mark style="background: #FFF3A3A6;">-r</mark>：递归删除整个文件夹
<mark style="background: #FFF3A3A6;">-f</mark>：强制删除而不提示
<mark style="background: #FFF3A3A6;">-rf</mark> 每删一个都会提示是否删除,加个-f可以一次性删除整个目录不提示
```bash
-----案例1：将/home/hello.txt删除-----
[root@SanxCentOS7 home] rm /home/hello.txt 
[root@SanxCentOS7 home] ls
#	bbb  ben  hello.txt  liuwendi  sanx  test

[root@SanxCentOS7 home] rm hello.txt 
#	rm：是否删除普通空文件 "hello.txt"？y

-----案例2：递归 删除整个文件夹/home/bbb-----
[root@SanxCentOS7 home] rm -rf bbb/
[root@SanxCentOS7 home] ls
#	ben  liuwendi  sanx  test

```

#### 移动,重命名文件和目录
<mark style="background: #FF5582A6;">mv [option] [file] [dir]</mark> 移动文件到指定目录
<mark style="background: #FF5582A6;">mv [option] [source] [dest]</mark>  移动目标目录到指定目录, 如果 `dest` 文件夹不存在, 那 `source` 文件夹就会重命名成`dest`, 如果`dest`文件夹存在, 那`source`就会被移动到`dest`目录下
<mark style="background: #FF5582A6;">mv [oldfilename] [newfilename]</mark> 将旧文件重命名成新文件,本质上是相对路径移动,在当前目录中,两个在同一目录的文件移动视作覆盖,也就是旧文件"移动"成新文件

```bash
-----案例1：将/home/cat.txt文件重新命名为pig.txt-----
[root@SanxCentOS7 home] touch cat.txt
[root@SanxCentOS7 home] ls
#	ben  cat.txt  sanx  test
[root@SanxCentOS7 home] mv cat.txt pig.txt
[root@SanxCentOS7 home] ls
#	ben  pig.txt  sanx  test

-----案例2：将/home/pig.txt文件移动到/root目录下-----
[root@SanxCentOS7 home] mv /home/pig.txt /root
[root@SanxCentOS7 home] ls
#	ben  sanx  test
[root@SanxCentOS7 home] cd /root/
[root@SanxCentOS7 ~] ls
# anaconda-ks.cfg  Hello.java  initial-setup-ks.cfg  pig.txt  公共  模板  视频  图片  文档  下载  音乐  桌面

特别的，如果 命令为  mv /home/pig.txt /root/cow.txt
那么，就是 移动并且重命名

-----案例3：移动整个目录-----
[root@SanxCentOS7 opt] mv bbb/ /home/
[root@SanxCentOS7 opt] ls
#	rh
[root@SanxCentOS7 opt] cd /home/
[root@SanxCentOS7 home] ls
#	bbb  ben  sanx  test
[root@SanxCentOS7 home] cd bbb/
[root@SanxCentOS7 bbb] ls
#	hello2.txt  hello.txt

```

#### 查看文件内容详情
<mark style="background: #FF5582A6;">cat [option] [file]</mark> 查看文件内容
`[option]`
<mark style="background: #FFF3A3A6;">-n</mark>: 显示行号
<mark style="background: #FFF3A3A6;">cat -n [file] |more</mark> 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令`|`加上more

<mark style="background: #FF5582A6;">more [file]</mark> 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。

| 操作          | 功能说明                             |     |
| ------------- | ------------------------------------ | --- |
| `Space `| 代表向下翻一页                       |     |
| `Enter `        | 代表向下翻 一行                      |     |
| `q `            | 代表立刻离开more，不再显示该文件内容 |     |
| `Ctrl+F`        | 向下滚动一屏                         |     |
| `Ctrl+B`        | 返回上一屏                           |     |
| \=           | 输出当前行的行号                     |     |
| `:f`            | 输出文件名和当前行的行号             |     |

<mark style="background: #FF5582A6;">less [file]</mark> 分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要来加载内容，对于显示大型文件具有较高的效率

| 操作     | 功能说明                                       |     |
| -------- | ---------------------------------------------- | --- |
| Space   | 向下翻动一页                                   |     |
| pagedown | 向下翻动一页                                   |     |
| pageup   | 向上翻动一页                                   |     |
| /\[字串\]    | 向下搜寻 \[字串\] 的功能；n：向下查找；N：向上查找 |     |
| ?\[字串\]    | 向上搜寻 \[字串\] 的功能；n：向下查找；N：向上查找 |     |
| q        | 离开 less 这个程序                             |     |

<mark style="background: #FF5582A6;">head [file]</mark> 用于显示文件的开头部分内容，默认情况下显示文件的前10行内容
<mark style="background: #FF5582A6;">tail [file]</mark> 用于输出文件中尾部的内容，默认情况下显示文件的前10行内容
<mark style="background: #FFF3A3A6;">head -n 5 [file]</mark>  查看文件头5行内容，5可以是任意数
<mark style="background: #FFF3A3A6;">tail -n 5 [file]</mark>  查看文件尾5行内容，5可以是任意数
<mark style="background: #FFF3A3A6;">tail -f [file]</mark>  实时追踪该文档的所有更新, 退出追踪需要使用 Ctrl + C
```bash

-----案例1：查看文件头部5行的内容-----
[root@SanxCentOS7 ~] head -n 5  /etc/profile

	# /etc/profile
	
	# System wide environment and startup programs, for login setup
	# Functions and aliases go in /etc/bashrc

-----案例2：查看文件尾部5行的内容-----
[root@SanxCentOS7 ~] tail -n 5  /etc/profile
#	    fi
#	done
	
#	unset i
#	unset -f pathmunge

-----案例3：实时追踪文件变化-----
[root@SanxCentOS7 ~] cd /home
[root@SanxCentOS7 home] touch mydate.txt
[root@SanxCentOS7 home] ls
#	bbb  ben  mydate.txt  sanx  test
[root@SanxCentOS7 home] tail -f mydate.txt 
#	hello

```

#### 输出终端内容
<mark style="background: #FF5582A6;">echo [option] [output]</mark>  输出内容到控制台, 
- 输出内容中不能添加感叹号，不然会识别错误
- 输出内容尽量使用单引号或者不使用符号

```bash
-----案例1：输出环境变量-----
[root@SanxCentOS7 ~] echo $HOSTNAME
#	SanxCentOS7
-----案例2：输出内容-----
[root@SanxCentOS7 ~] echo "hello,world"
#	hello,world
[root@SanxCentOS7 ~] echo "hello,world!"
#	-bash: !": event not found
[root@SanxCentOS7 ~] echo hello,world
#	hello,world
[root@SanxCentOS7 ~] echo hello,world!
#	hello,world!
[root@SanxCentOS7 ~] echo 'hello,world!'
#	hello,world!

```

#### 重定向操作符(追加和覆盖)

<mark style="background: #FF5582A6;"> > </mark>   输出重定向到某个流中, 作用是覆盖
<mark style="background: #FF5582A6;"> >> </mark>  输出追加到某个流中, 作用是追加
<mark style="background: #FFF3A3A6;">ls -l > [file]</mark> 列表的内容写入文件中 这里是覆盖写, 如果没有该文件，那么系统会自动创建一个文件
<mark style="background: #FFF3A3A6;">ls -al > [file]</mark> 列表的内容追加到文件的末尾
<mark style="background: #FFF3A3A6;">cat [file1] > [file2]</mark> 将`file1`的内容覆盖到`file2` 如果 `txt.a` 文件不存在，则会创建它
<mark style="background: #FFF3A3A6;">echo 'output' >> [file]</mark> 将`out`的内容追加到`file2`
<mark style="background: #FFF3A3A6;">clac >> [file]</mark> 将日期信息追加到`file`，如果`file`不存在就会自动创建一个文件
```bash
-----案例1：将 /home 目录下的文件列表写入到 /home/info.txt文件中-----
[root@SanxCentOS7 home] ls -l /home/
#	drwxr-xr-x. 2 root     root     4096 10月  8 16:15 bbb
#	drwx------. 5 ben      ben      4096 10月  7 20:41 ben
#	-rw-r--r--. 1 root     root        6 10月  9 15:06 mydate.txt
#	drwx------. 5 sanx     sanx     4096 10月  7 15:24 sanx
#	drwx------. 3 xiaohong xiaohong 4096 10月  7 15:33 test

-----系统自动创建一个叫 info.txt 的文件-----
[root@SanxCentOS7 home] ls -l /home/ > /home/info.txt
[root@SanxCentOS7 home] ls -l
#	drwxr-xr-x. 2 root     root     4096 10月  8 16:15 bbb
#	drwx------. 5 ben      ben      4096 10月  7 20:41 ben
#	-rw-r--r--. 1 root     root      363 10月  9 15:30 info.txt
#	-rw-r--r--. 1 root     root        6 10月  9 15:06 mydate.txt
#	drwx------. 5 sanx     sanx     4096 10月  7 15:24 sanx
#	drwx------. 3 xiaohong xiaohong 4096 10月  7 15:33 test
[root@SanxCentOS7 home] cat info.txt 
#	drwxr-xr-x. 2 root     root     4096 10月  8 16:15 bbb
#	drwx------. 5 ben      ben      4096 10月  7 20:41 ben
#	-rw-r--r--. 1 root     root        0 10月  9 15:30 info.txt
#	-rw-r--r--. 1 root     root        6 10月  9 15:06 mydate.txt
#	drwx------. 5 sanx     sanx     4096 10月  7 15:24 sanx
#	drwx------. 3 xiaohong xiaohong 4096 10月  7 15:33 test

-----证明了 >指令 是覆盖写的-----
[root@SanxCentOS7 home] echo 'ok' > info.txt 
[root@SanxCentOS7 home] cat info.txt 
#	ok

-----将日期信息写入到文件中-----
[root@SanxCentOS7 home] cal
#	      十月 2022     
#	日 一 二 三 四 五 六
#	                   1
#	 2  3  4  5  6  7  8
#	 9 10 11 12 13 14 15
#	16 17 18 19 20 21 22
#	23 24 25 26 27 28 29
#	30 31

-----可以看到是自动创建的文件-----
[root@SanxCentOS7 home] cal >> /home/mycal
[root@SanxCentOS7 home] ls
#	bbb  ben  info.txt  mycal  mydate.txt  sanx  test
[root@SanxCentOS7 home]# cat mycal
#	      十月 2022     
#	日 一 二 三 四 五 六
#	                   1
#	 2  3  4  5  6  7  8
#	 9 10 11 12 13 14 15
#	16 17 18 19 20 21 22
#	23 24 25 26 27 28 29
#	30 31

-----可以看到 >>指令 是追加进行的-----
[root@SanxCentOS7 home] cal >> /home/mycal
[root@SanxCentOS7 home] cat mycal
#	      十月 2022     
#	日 一 二 三 四 五 六
#	                   1
#	 2  3  4  5  6  7  8
#	 9 10 11 12 13 14 15
#	16 17 18 19 20 21 22
#	23 24 25 26 27 28 29
#	30 31
#	      十月 2022     
#	日 一 二 三 四 五 六
#	                   1
#	 2  3  4  5  6  7  8
#	 9 10 11 12 13 14 15
#	16 17 18 19 20 21 22
#	23 24 25 26 27 28 29
#	30 31

-----案例2：将/etc/profile 下的文件覆盖到 /home/myprofile下------
[root@SanxCentOS7 home] cat /etc/profile >> /home/myprofile
[root@SanxCentOS7 home] ls
#	bbb  ben  info.txt  mycal  mydate.txt  myprofile  sanx  test
```

#### 软链接
<mark style="background: #FF5582A6;">ln -s [file OR dir] [linkname]</mark> 给原文件或目录创建一个软链接, 软链接也称为符号链接，类似于 Windows 里的快捷方式，主要存放了链接其他文件的路径, 删除直接用 `rm` 就可以直接删除
- 当我们使用 `pwd `查看目录时，仍然看到的是软链接所在的目录

```bash

------案例1：在 /home 下创建一个软连接到 /root-----
[root@SanxCentOS7 home] ln -s /root/ /home/myroot
[root@SanxCentOS7 home] ls
#	bbb  ben  info.txt  mycal  mydate.txt  myprofile  myroot  sanx  test
[root@SanxCentOS7 home] ls -l
#	drwxr-xr-x. 2 root     root     4096 10月  8 16:15 bbb
#	drwx------. 5 ben      ben      4096 10月  7 20:41 ben
#	-rw-r--r--. 1 root     root        3 10月  9 15:31 info.txt
#	-rw-r--r--. 1 root     root      324 10月  9 15:36 mycal
#	-rw-r--r--. 1 root     root        6 10月  9 15:06 mydate.txt
#	-rw-r--r--. 1 root     root     1819 10月  9 15:38 myprofile
#	lrwxrwxrwx. 1 root     root        6 10月  9 16:36 myroot -> /root/  
	# 上一行的myroot就是软链接的指向文件(也就是root文件夹的快捷方式)
#	drwx------. 5 sanx     sanx     4096 10月  7 15:24 sanx
#	drwx------. 3 xiaohong xiaohong 4096 10月  7 15:33 test

-----ls查看文件目录下的文件，发现都是/root下的文件-----
[root@SanxCentOS7 home] cd myroot/
[root@SanxCentOS7 myroot] ls -l
#	-rw-------. 1 root root 1887 10月  6 23:18 anaconda-ks.cfg
#	-rw-r--r--. 1 root root  131 10月  7 14:42 Hello.java
#	-rw-r--r--. 1 root root 1918 10月  6 23:21 initial-setup-ks.cfg
#	-rw-r--r--. 1 root root    0 10月  8 17:01 pig.txt
#	drwxr-xr-x. 2 root root 4096 10月  6 23:22 公共
#	drwxr-xr-x. 2 root root 4096 10月  6 23:22 模板
#	drwxr-xr-x. 2 root root 4096 10月  6 23:22 视频
#	drwxr-xr-x. 2 root root 4096 10月  6 23:22 图片
#	drwxr-xr-x. 2 root root 4096 10月  6 23:22 文档
#	drwxr-xr-x. 2 root root 4096 10月  6 23:22 下载
#	drwxr-xr-x. 2 root root 4096 10月  6 23:22 音乐
#	drwxr-xr-x. 2 root root 4096 10月  6 23:22 桌面

-----删除软链接，rm /home/root 注意，不要加 “/” 不然系统会认为这是一个文件-----
[root@SanxCentOS7 myroot] cd /home/
[root@SanxCentOS7 home] rm /home/myroot/
#	rm: 无法删除"/home/myroot/": 是一个目录
[root@SanxCentOS7 home] rm /home/myroot
#	rm：是否删除符号链接 "/home/myroot"？y
[root@SanxCentOS7 home] ll
#	drwxr-xr-x. 2 root     root     4096 10月  8 16:15 bbb
#	drwx------. 5 ben      ben      4096 10月  7 20:41 ben
#	-rw-r--r--. 1 root     root        3 10月  9 15:31 info.txt
#	-rw-r--r--. 1 root     root      324 10月  9 15:36 mycal
#	-rw-r--r--. 1 root     root        6 10月  9 15:06 mydate.txt
#	-rw-r--r--. 1 root     root     1819 10月  9 15:38 myprofile
#	drwx------. 5 sanx     sanx     4096 10月  7 15:24 sanx
#	drwx------. 3 xiaohong xiaohong 4096 10月  7 15:33 test

```


#### 查看历史命令
<mark style="background: #FF5582A6;">history [num] </mark> 查看已经执行过历史命令，输入num可以快速查看最近执行的n条指令
<mark style="background: #FF5582A6;">! [num]</mark> `history` 出来之后, 可以快速执行第num条指令
```bash
-----案例1：查看最近执行的10条指令 history 10-----
[root@SanxCentOS7 home] history 10
#	  246  ls -l
#	  247  cd myroot/
#	  248  ls
#	  249  ls -l
#	  250  cd /home/
#	  251  rm /home/myroot/
#	  252  rm /home/myroot
#	  253  ll
#	  254  history
#	  255  history 10

-----案例2：执行某个编号的指令 !+编号 -----
#	  250  cd /home/
#	  251  rm /home/myroot/
#	  252  rm /home/myroot
#	  253  ll
#	  254  history
#	  255  history 10
#	  256  man ln
#	  257  history
[root@SanxCentOS7 home] !256
#	man ln

```

#### 软件包管理
`rpm`（Red Hat Package Manager）是一种在类Unix系统中用于软件包管理的工具，最初由Red Hat开发，现在也被其他Linux发行版采用。RPM主要用于安装、升级、卸载和查询系统上安装的软件包。

1. **安装软件包：**
   ```bash
   rpm -ivh package.rpm
   ```
   通过这个命令，你可以安装一个.rpm格式的软件包。选项 `-i` 表示安装，`-v` 表示详细模式，`-h` 表示显示进度。

2. **查询软件包信息：**
   ```bash
   rpm -q package_name
   ```
   用于查询已安装软件包的信息，包括版本、发布信息等。

3. **列出已安装软件包：**
   ```bash
   rpm -qa
   ```
   这个命令列出系统上所有已安装的软件包。

4. **升级软件包：**
   ```bash
   rpm -Uvh package.rpm
   ```
   用于升级已经安装的软件包，选项 `-U` 表示升级。

5. **卸载软件包：**
   ```bash
   rpm -e package_name
   ```
   通过这个命令，你可以卸载已安装的软件包。

6. **查询文件属于哪个软件包：**
   ```bash
   rpm -qf /path/to/file
   ```
   这个命令用于查询某个文件属于哪个软件包。

7. **列出软件包中的文件：**
   ```bash
   rpm -ql package_name
   ```
   通过这个命令，你可以列出软件包中包含的文件。

请注意，上述命令中的`package.rpm`和`package_name`应替换为实际的软件包文件名或软件包的名称。`rpm`是特定于Red Hat及其衍生发行版的包管理工具，其他发行版可能使用不同的包管理工具，如Debian系的`dpkg`。

#### 磁盘查看/显示文件系统空间使用情况
<mark style="background: #FF5582A6;">df [option] [file system]</mark> `df` 是一个用于显示磁盘空间使用情况的命令

`option`

1. **`-h` 或 `--human-readable`：** 以易读的方式显示磁盘空间，使用 K、M、G 等单位。
   ```bash
   df -h
   ```

2. **`-T` 或 `--print-type`：** 显示文件系统类型。
   ```bash
   df -T
   ```

3. **`-a` 或 `--all`：** 显示所有文件系统，包括系统特有的伪文件系统。
   ```bash
   df -a
   ```

4. **`-i` 或 `--inodes`：** 显示 inode 使用情况而不是磁盘空间。
   ```bash
   df -i
   ```
`df` 命令默认显示文件系统的块数、已用空间、可用空间、已用百分比和挂载点。这对于监视磁盘空间的使用情况以及判断是否需要清理空间非常有用。

#### 查看进程
<mark style="background: #FF5582A6;">top</mark> 是一个在终端中用于实时显示系统资源使用情况的命令行工具。它提供了一个交互式的实时系统监视器，可以显示当前运行的进程、CPU 使用率、内存使用情况、交换空间使用情况以及其他系统资源的统计信息。

`top` 界面中的信息实时更新，你可以看到各个进程的资源占用情况，并按不同的排序方式查看。一些常用的快捷键包括：
- `q`：退出 `top`。
- `Space`：更新显示。
- `k`：杀死进程。
- `H`：显示或隐藏用户线程。
`top` 是一个强大的系统监视工具，可用于检查系统性能、识别资源密集型进程以及实时监控系统资源的变化。

## 时间日期类

#### 显示当前日期
<mark style="background: #FF5582A6;">date</mark> 是显示当前的日期

<mark style="background: #FFF3A3A6;">date +%Y</mark> 显示当前年份
<mark style="background: #FFF3A3A6;">date +%m</mark> 显示当前月份
<mark style="background: #FFF3A3A6;">date +%d</mark> 显示当前是哪一天
<mark style="background: #FFF3A3A6;">date "+%Y-%m-%d %H:%M:%S"</mark> 显示年月日时分秒
<mark style="background: #FFF3A3A6;">date -s "2020-11-11 12:12:12"</mark> 修改年月日时分秒
<mark style="background: #FF5582A6;">ntpdate asia.pool.ntp.org</mark>  恢复网络同步时间
```bash

[root@SanxCentOS7 home] date
#	2022年 10月 09日 星期日 17:03:06 CST
[root@SanxCentOS7 home] date +%Y
#	2022
[root@SanxCentOS7 home] date "+%Y %m"
#	2022 10
[root@SanxCentOS7 home] date "+%Y-%m"
#	2022-10
[root@SanxCentOS7 home] date "+%Y-%m-%d"
#	2022-10-09
[root@SanxCentOS7 home] date "+%Y-%m-%d %H"
#	2022-10-09 17
[root@SanxCentOS7 home] date "+%Y-%m-%d %H-%M"
#	2022-10-09 17-06

-----表达式的符号可以随意改动，中间的符号就是用来符合人类习惯的-----

[root@SanxCentOS7 home] date "+%Y-%m-%d %H-%M-%S"
#	2022-10-09 17-06-36
[root@SanxCentOS7 home] date "+%Y-%m-%d %H:%M:%Ss"
#	2022-10-09 17:06:54s

```

```bash
-----手动设置时间-----
[root@SanxCentOS7 home] date -s "2020-11-11 12:12:12"
#	2020年 11月 11日 星期三 12:12:12 CST
[root@SanxCentOS7 home] date
#	2020年 11月 11日 星期三 12:12:15 CST

-----恢复网络同步时间-----
[root@SanxCentOS7 home] ntpdate asia.pool.ntp.org
#	 9 Oct 17:16:46 ntpdate[16939]: step time server 202.118.1.81 offset 60239058.815056 sec
[root@SanxCentOS7 home] date
#	2022年 10月 09日 星期日 17:16:52 CST

```

#### 查看日历(年月)
<mark style="background: #FF5582A6;">cal [year]</mark> 不加选项，显示本月日历, 加年份的话就显示整年日历

```bash
-----显示当前的日历-----
[root@SanxCentOS7 home] cal
#      十月 2022     
# 日 一 二 三 四 五 六
#                    1
#  2  3  4  5  6  7  8
#  9 10 11 12 13 14 15
# 16 17 18 19 20 21 22
# 23 24 25 26 27 28 29
# 30 31

-----显示2020年整年的日历-----
[root@SanxCentOS7 home] cal 2020

#                              2020                               
#
#        一月                   二月                   三月        
#  日 一 二 三 四 五 六     日 一 二 三 四 五 六     日 一 二 三 四 五 六
#           1  2  3  4                      1    1  2  3  4  5  6  7
#  5  6  7  8  9 10 11    2  3  4  5  6  7  8    8  9 10 11 12 13 14
# 12 13 14 15 16 17 18    9 10 11 12 13 14 15   15 16 17 18 19 20 21
# 19 20 21 22 23 24 25   16 17 18 19 20 21 22   22 23 24 25 26 27 28
# 26 27 28 29 30 31      23 24 25 26 27 28 29   29 30 31
#
#        四月                   五月                   六月        
# 日 一 二 三 四 五 六       日 一 二 三 四 五 六    日 一 二 三 四 五 六
#           1  2  3  4                   1  2       1  2  3  4  5  6
# 5  6  7  8  9 10 11    3  4  5  6  7  8  9    7  8  9 10 11 12 13
# 12 13 14 15 16 17 18   10 11 12 13 14 15 16   14 15 16 17 18 19 20
# 19 20 21 22 23 24 25   17 18 19 20 21 22 23   21 22 23 24 25 26 27
# 26 27 28 29 30         24 25 26 27 28 29 30   28 29 30
#                        31
#        七月                   八月                   九月        
# 日 一 二 三 四 五 六      日 一 二 三 四 五 六     日 一 二 三 四 五 六
#           1  2  3  4                      1          1  2  3  4  5
#  5  6  7  8  9 10 11    2  3  4  5  6  7  8    6  7  8  9 10 11 12
# 12 13 14 15 16 17 18    9 10 11 12 13 14 15   13 14 15 16 17 18 19
# 19 20 21 22 23 24 25   16 17 18 19 20 21 22   20 21 22 23 24 25 26
# 26 27 28 29 30 31      23 24 25 26 27 28 29   27 28 29 30
#                        30 31
#        十月                  十一月                 十二月       
# 日 一 二 三 四 五 六       日 一 二 三 四 五 六     日 一 二 三 四 五 六
#              1  2  3    1  2  3  4  5  6  7          1  2  3  4  5
#  4  5  6  7  8  9 10    8  9 10 11 12 13 14    6  7  8  9 10 11 12
# 11 12 13 14 15 16 17   15 16 17 18 19 20 21   13 14 15 16 17 18 19
# 18 19 20 21 22 23 24   22 23 24 25 26 27 28   20 21 22 23 24 25 26
# 25 26 27 28 29 30 31   29 30                  27 28 29 30 31

```

## 搜索查找类

#### 范围搜索文件

<mark style="background: #FF5582A6;">find [dir] [option]
</mark> 将从指定目录向下递归地便利其各个子目录，将满足条件的文件或者目录显示

`[option]`
<mark style="background: #FFF3A3A6;">-name [filename]</mark> 按照指定文件名查找模式查找文件
<mark style="background: #FFF3A3A6;">-user [username]</mark> 查找属于指定用户名所有文件
<mark style="background: #FFF3A3A6;">-size [n]</mark> 按照指定的文件大小查找文件,(+n大于 -n小于 n等于, 单位有k,M,G)
<mark style="background: #FFF3A3A6;">-type d </mark>  指定文件的类型是目录

```bash
-----按文件名查找/home目录下的hello.txt文件-----
[root@SanxCentOS7 ~] find /home -name hello.txt
#	/home/bbb/hello.txt

-----按用户名查找/opt目录下，用户名称为nobody的文件-----
[root@SanxCentOS7 ~] find /opt -user nobody #没找到文件就不会显示什么
[root@SanxCentOS7 ~] find /opt -user root
#	/opt
#	/opt/rh

-----查找整个Linux系统下大于200M的文件(+n大于 -n小于 n等于 单位有k、M、G)-----
[root@SanxCentOS7 ~] find / -size +200M
#	/proc/kcore
#	find: ‘/proc/2708/task/2708/fd/5’: 没有那个文件或目录
#	find: ‘/proc/2708/task/2708/fdinfo/5’: 没有那个文件或目录
#	find: ‘/proc/2708/fd/6’: 没有那个文件或目录
#	find: ‘/proc/2708/fdinfo/6’: 没有那个文件或目录
#	/run/media/root/CentOS 7 x86_64/LiveOS/squashfs.img

[root@SanxCentOS7 ~] cd /run/media/root/CentOS\ 7\ x86_64/LiveOS/
[root@SanxCentOS7 LiveOS] ls
#	squashfs.img  TRANS.TBL
[root@SanxCentOS7 LiveOS] ls -l
#	总用量 509393
#	-rw-r--r--. 3 root root 521617408 10月 27 2020 squashfs.img
#	-r--r--r--. 1 root root       224 11月  4 2020 TRANS.TBL
[root@SanxCentOS7 LiveOS] ls -lh
#	总用量 498M
#	-rw-r--r--. 3 root root 498M 10月 27 2020 squashfs.img
#	-r--r--r--. 1 root root  224 11月  4 2020 TRANS.TBL

```

#### 定位文件位置

<mark style="background: #FF5582A6;">locate [file]</mark> 可以快速定位文件路径,locate指令利用事先建立的系统中所有文件名称及路径的locate数据库，实现快速定位给定的文件, locate指令无需遍历整个文件系统，查询速度较快，为了保证查询结果的准确度，管理员必须定期更新locate时刻.
<mark style="background: #FFF3A3A6;">updatedb</mark> 由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令 创建 locate数据库, 不先执行的话, locate是无法定位文件的
<mark style="background: #FF5582A6;">which [cmdname]</mark> 查看某个指令所存放的文件目录
```bash
-----使用locate指令快速定位hello.txt文件所在目录-----
[root@SanxCentOS7 LiveOS] updatedb
[root@SanxCentOS7 LiveOS] locate hello.txt
#	/home/bbb/hello.txt
```

```bash
[root@SanxCentOS7 LiveOS] which ls
#	alias ls='ls --color=auto'
#	/usr/bin/ls
[root@SanxCentOS7 LiveOS] which reboot
#	/usr/sbin/reboot

```

#### 过滤查找和管道命令
![[Pasted image 20231208165218.png]]
<mark style="background: #FF5582A6;"> | </mark>  管道符 “|”，表示将前一个命令的处理结果输出传递给后面的命令处理
<mark style="background: #FF5582A6;">grep [option] [string] [source]</mark>  过滤查找某一个字符串在, grep 命令中，“^” 表示行首（即开头）。所以，“^-” 表示以 “-” 开头的行，“$” 表示行尾（即结尾）

`[option]`
<mark style="background: #FFF3A3A6;">-n</mark>	显示匹配行及行号
<mark style="background: #FFF3A3A6;">-i</mark>	忽略字母的大小写

- 例如我查找一个a.txt文件中是否有字符串'hello'
- 那么，bash下的命令可以是 cat a.txt | grep "hello"
- 此处管道符 "|" 就是把前面的命令结果交给后面处理的
```bash
-----在hello.txt文件中，查找yes所在行，并显示行号-----
写法1
[root@SanxCentOS7 LiveOS] cat /home/bbb/hello.txt 
#	ok
#	fine
#	yes
#	ohyes
#	hello
#	test
#	yes
#	YES
[root@SanxCentOS7 LiveOS] cat /home/bbb/hello.txt | grep -n "yes"
#	3:yes
#	4:ohyes
#	7:yes

写法2：
[root@SanxCentOS7 LiveOS] grep -n "yes" /home/bbb/hello.txt
#	3:yes
#	4:ohyes
#	7:yes

[root@SanxCentOS7 LiveOS] cat /home/bbb/hello.txt | grep -n -i "yes"
#	3:yes
#	4:ohyes
#	7:yes
#	8:YES

```

## 压缩解压类
#### 解压缩.GZ文件
<mark style="background: #FF5582A6;">gzip [file]</mark>  压缩文件，只能将文件压缩为 “.gz文件”
<mark style="background: #FF5582A6;">gunzip [file.gz]</mark>  解压".gz文件"

```bash
-----gzip压缩，将/home下的hello.txt文件进行压缩-----
[root@SanxCentOS7 LiveOS] gzip /home/bbb/hello.txt 
[root@SanxCentOS7 LiveOS] cd /home/bbb/
[root@SanxCentOS7 bbb] ls -lh
#	总用量 4.0K
#	-rw-r--r--. 1 root root  0 10月  8 16:19 hello2.txt
#	-rw-r--r--. 1 root root 61 10月 30 14:40 hello.txt.gz

-----gunzip压缩，将/home下的hello.txt.gz文件进行解压缩-----
[root@SanxCentOS7 bbb] gunzip hello.txt.gz 
#	gzip: hello.txt already exists; do you wish to overwrite (y or n)? y
[root@SanxCentOS7 bbb] ls -lh
#	总用量 4.0K
#	-rw-r--r--. 1 root root 37 10月 30 14:40 hello.txt

```

#### 解压缩.ZIP文件
<mark style="background: #FF5582A6;">zip [option] [file OR dir]</mark> 压缩文件和目录
<mark style="background: #FF5582A6;">unzip [option] [file.zip]</mark> 解压文件

<mark style="background: #FFF3A3A6;">zip -r [filename] [dir]</mark>  将dir目录(连同dir本身)压缩成一个名为 filename.zip 文件(里边的-r就是递归)
<mark style="background: #FFF3A3A6;">unzip -d [dest] [src.zip]</mark>  把 src.zip 文件解压到 dest 目录, 如果不写dest,  就默认解压到当前路径

```bash
-----将/home下的所有文件进行压缩成 myhome.zip-----
[root@SanxCentOS7 ~] zip -r myhome.zip /home/
[root@SanxCentOS7 ~] ls
#	anaconda-ks.cfg  Hello.java  initial-setup-ks.cfg  myhome.zip  pig.txt  公共  模板  视频  图片  文档  下载  音乐  桌面

-----将 myhome.zip 解压到 /opt/tmp 目录下-----
[root@SanxCentOS7 ~] mkdir /opt/tmp
[root@SanxCentOS7 ~] unzip -d /opt/tmp/ /root/myhome.zip
[root@SanxCentOS7 /] cd /opt/
[root@SanxCentOS7 opt] ls
#	rh  tmp
[root@SanxCentOS7 opt] cd tmp/
[root@SanxCentOS7 tmp] ls
#	home

```

#### 解压缩.TAR.GZ文件

<mark style="background: #FF5582A6;">tar [option] [file.tar.gz] []</mark> 

`[option]`
<mark style="background: #FFF3A3A6;">-c</mark>	产生 .tar打包文件
<mark style="background: #FFF3A3A6;">-v</mark>	显示详细信息
<mark style="background: #FFF3A3A6;">-f</mark>	指定压缩后的文件名
<mark style="background: #FFF3A3A6;">-z</mark>	打包同时压缩
<mark style="background: #FFF3A3A6;">-x</mark>	解包 .tar文件
<mark style="background: #FFF3A3A6;">-zcvf</mark>  创建一个经过 gzip 压缩的归档文件，并在过程中显示详细信息。
<mark style="background: #FFF3A3A6;">-zxvf</mark>  从一个经过 gzip 压缩的归档文件中解压缩文件，并在过程中显示详细信息。
<mark style="background: #FFF3A3A6;">tar -zcvf [file.tar.gz] [file1 OR dir1] [file2 OR dir2]</mark> ,
<mark style="background: #FFF3A3A6;">tar -zxvf [src.tar.gz] -C [dest]</mark> , 此处的 -C 是 代表着你解压的包需要解压到哪一个文件目录里
解压xxx.tar.gz 到 解压目的文件目录

```bash
-----案例1：压缩多个文件，将/home/pig.txt和/home/cat.txt压缩成pc.tar.gz-----
[root@SanxCentOS7 home] ls
#	bbb  ben  info.txt  mycal  mydate.txt  myprofile  sanx  test
[root@SanxCentOS7 home] touch pig.txt
[root@SanxCentOS7 home] touch cat.txt
[root@SanxCentOS7 home] ls
#	bbb  ben  cat.txt  info.txt  mycal  mydate.txt  myprofile  pig.txt  sanx  test
[root@SanxCentOS7 home] tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt 
tar: 从成员名中删除开头的“/”
#	/home/pig.txt
#	/home/cat.txt
[root@SanxCentOS7 home] ls
#	bbb  ben  cat.txt  info.txt  mycal  mydate.txt  myprofile  pc.tar.gz  pig.txt  sanx  test

-----案例2：将/home的文件夹压缩成myhome.tar.gz-----
[root@SanxCentOS7 home] tar -zcvf myhome.tar.gz /home/
#省略压缩过程......
[root@SanxCentOS7 home] ls
#	bbb  ben  cat.txt  info.txt  mycal  mydate.txt  myhome.tar.gz  myprofile  pc.tar.gz  pig.txt  sanx  test

-----案例3：将pc.tar.gz解压到当前目录，切换到/opt/-----
[root@SanxCentOS7 home] ls
#	bbb  ben  cat.txt  info.txt  mycal  mydate.txt  myhome.tar.gz  myprofile  pc.tar.gz  pig.txt  sanx  test
[root@SanxCentOS7 home] rm cat.txt 
#	rm：是否删除普通空文件 "cat.txt"？y
[root@SanxCentOS7 home] rm pig.txt 
#	rm：是否删除普通空文件 "pig.txt"？y
[root@SanxCentOS7 home] ls
#	bbb  ben  info.txt  mycal  mydate.txt  myhome.tar.gz  myprofile  pc.tar.gz  sanx  test
[root@SanxCentOS7 home] tar -zxvf pc.tar.gz 
#	home/pig.txt
#	home/cat.txt
[root@SanxCentOS7 home] ls
#	bbb  ben  home  info.txt  mycal  mydate.txt  myhome.tar.gz  myprofile  pc.tar.gz  sanx  test
[root@SanxCentOS7 home] cd home/
[root@SanxCentOS7 home] ls
#	cat.txt  pig.txt

-----案例4：将myhome.tar.gz解压到/opt/tmp2目录下-----
[root@SanxCentOS7 home] mkdir /opt/tmp2
[root@SanxCentOS7 home] cd /opt/
[root@SanxCentOS7 opt] ls
#	rh  tmp  tmp2
[root@SanxCentOS7 opt] cd /home/
[root@SanxCentOS7 home] ls
#	bbb  ben  home  info.txt  mycal  mydate.txt  myhome.tar.gz  myprofile  pc.tar.gz  sanx  test
[root@SanxCentOS7 home] tar -zxvf /home/myhome.tar.gz -C /opt/tmp2/
[root@SanxCentOS7 home] cd /opt/tmp2
[root@SanxCentOS7 tmp2] ls
#	home
[root@SanxCentOS7 tmp2] cd home/
[root@SanxCentOS7 home] ls
#	bbb  ben  cat.txt  info.txt  mycal  mydate.txt  myprofile  pc.tar.gz  pig.txt  sanx  test
[root@SanxCentOS7 home] pwd
#	/opt/tmp2/home


```

## shell脚本编程



#### 检查给定的目录是否存在并输出文件内容

这是一个简单的 Bash 脚本，用于检查给定的目录是否存在，然后遍历该目录下的所有文件，如果是普通文件，则输出文件的内容。以下是对代码的逐行解释：

```bash
#!/bin/bash                          #（1） 指定脚本使用 Bash 解释器

dir=$1                               #（2） 将脚本的第一个命令行参数（目录名）赋给变量 dir

if [ -d $dir ]                       #（3） 检查目录是否存在
then
  cd $dir                            #（4） 如果目录存在，进入该目录

  for file in *                      # 遍历目录下的所有文件
  do
    if [ -f $file ]                  #（5） 检查当前项是否为普通文件
    then
      cat $file                      #（6） 如果是普通文件，则输出文件的内容
      echo "end of file $file"
    fi
  done

else
  echo "bad directory name $dir"    # 如果目录不存在，输出错误消息
fi
```

#### 整数的和值和最值
  
这是一个用来接收用户输入的100个整数，并计算它们的总和、最大值和最小值的Shell脚本。以下是对代码的逐行解释：

```bash

#!/bin/sh
read max
min=$max
sum=$max
i=1
while [ $i -lt 100 ]  # 循环100次，读取用户输入的整数
do
    read x
    sum=`expr $sum + $x`  # 计算总和

    if [ $max -lt $x ]  # 判断最大值
    then
        max=$x
    fi

    if [ $x -lt $min ]  # 判断最小值
    then
        min=$x
    fi

    i=`expr $i + 1`  # 更新循环计数器
done

echo "sum = $sum ;   max = $max    min = $min "

```

