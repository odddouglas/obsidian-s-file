

## 基础语法

#### 声明变量
```ts
let tmp="nb"; //声明字符变量
const tmp1="bnb";//声明字符常量
var tmp2=111; //声明数字变量 ,这个是js的语法,由于ts是js的超集,因此ts也同样适用
```
#### 指定类型和隐式转换
	在变量后面加上一个引号(:)指定类型
	加上一个双引号(" ")可以隐式转换类型
```ts
let all:any="nb";//跟不指定类型时一样,能够接收任何变量,这个any可以不写
let tmp2:string="bnbn";//声明字符变量并指定类型
let num:number=111;//声明数字变量
let flag:boolean=false;//声明布尔变量
document.write(num+'');//隐式转换成字符串然后打印 
```
#### 赋空值
```ts
//字符串
let str: string = 'Hello, World!'; // 初始化一个字符串变量
str = ''; // 将字符串变量设置为空字符串
console.log(str); // 输出: ''

let emptyStr: string = ''; // 直接将字符串变量初始化为空字符串
console.log(emptyStr); // 输出: ''

//数字
let num: number = 42; // 初始化一个数字变量
num = null; // 赋予空值（null）
console.log(num); // 输出: null

let anotherNum: number | undefined = 123; // 使用联合类型声明变量，可以赋予空值（undefined）
anotherNum = undefined; // 赋予空值（undefined）
console.log(anotherNum); // 输出: undefined

```
#### 类型别名和类型验证
```ts
type NewNumber = number;//为类型名number取一个新的名字叫NewNumber
let num: NewNumber =3; //此时定义一个NewNumber的变量num
document.write(typeof num);//此时变量的类型是NewNumber也是number,但是只输出number
```

## 输出语句以及模板字符串

#### 控制台输出
```ts
console.log('Hello, World!');
```
-   用于在浏览器的开发者工具控制台或其他支持JavaScript控制台输出的环境中打印信息。
-   它不会直接修改HTML文档的内容，而是将信息输出到控制台供开发者查看。
-   通常用于调试和日志记录目的，方便开发者查看程序的执行结果和错误信息。
-   它不会影响页面的渲染或结构。
#### 网页输出
```ts
document.write('<h1>Hello, World!</h1>');
```
-   用于在浏览器环境中直接向HTML文档写入内容。
-   它将指定的内容直接插入到文档中调用它的位置，会覆盖现有的文档内容。
-   可以在页面加载时或在脚本中的任何位置使用。
-   如果多次调用`document.write()`，它会逐个输出结果，按照调用的顺序依次插入到文档中。
#### 模板字符串
```ts
const name = 'Alice';
const age = 25;

// 使用模板插值
const greeting = `Hello, my name is ${name} and I'm ${age} years old.`;
console.log(greeting); // 输出: Hello, my name is Alice and I'm 25 years old.

// 多行字符串
const multilineString = `This is a
multi-line
string.`;
console.log(multilineString);
// 输出:
// This is a
// multi-line
// string.
```
1.  使用反引号 `` ` `` 来定义模板字符串。
2.  在模板字符串中可以包含变量、表达式和换行符。
3.  变量或表达式可以使用 `${}` 来插入到模板字符串中，称为模板插值。
4.  插入的变量或表达式会被自动转换为字符串并嵌入到模板中。
5.  可以使用多行字符串而无需显式拼接或转义换行符。
6.  可以在模板字符串中使用普通字符串的转义序列（如 `\n`、`\t` 等）。

## 一些规则

#### 枚举
- 枚举使用符号 .  来访问枚举变量
```ts
enum Direction 
{
  Up,
  Down,
  Left,
  Right
}

enum States
{
	idle=2,
	run,
	death=10,
	attack
}

let dir: Direction = Direction.Up; // 使用枚举成员初始化变量
console.log(dir); // 输出: 0

if (dir === Direction.Up) // 使用枚举成员进行条件判断
{ 
  console.log("Go Up!");
}

let state:State=State.dile;
switch (state)
{
	case State.idle: document.write("idle");
	case State.run: document.write("run");
	case State.death: document.write("death");
	case State.attack: document.write("attack");
	default :document.write("other states");
}
console.log(Direction[2]); // 输出: "Left"，通过值获取对应的名称

```

#### 泛型
- 它允许我们编写能够适用于多种数据类型的函数、类或接口
```ts
function add(num:any): any //任何类型的参数和任何类型的返回值
{
	if(typeof num =="number") //如果是数字就进行自增
	{
		num++;
		return num;
	}	
	return num; //输入和输出的类型可能不一致
}

function add<T> (num:T):T //这个<T>加在函数名add后面
{
	if(typeof num =="number") //如果是数字就进行自增
	{
		num++;
		return num;
	}	
	return num; //限定了输入输出的类型必须一致
}
```
  
- 这两种实现方式都是可以实现对数字类型的自增操作，但是它们有一些区别即 **类型安全性**：
    -   第一种实现方式：`function add(num: any): any`
        这种方式使用了`any`类型来表示参数和返回值，意味着函数可以接收任何类型的参数，并返回任何类型的值。这样的实现在使用时非常灵活，但是也丧失了类型安全性，因为函数在调用时无法确定输入参数的类型，也无法保证返回值的类型与输入参数相同。
    -   第二种实现方式：`function add<T>(num: T): T`
        这种方式使用了泛型（`<T>`）来表示参数和返回值的类型。通过使用泛型，我们可以在调用时指定具体的类型，使得函数在使用时具有更好的类型安全性。例如，当我们调用`add<number>(5)`时，`T`会被替换为`number`，使得参数和返回值都是`number`类型。这样在编译时就能保证参数和返回值的类型一致。

#### 比较运算符

	相等性运算符（`==`和`===`）：
	`==`运算符用于比较两个值是否相等，它会进行类型强制转换。
	`===`运算符用于比较两个值是否严格相等，不进行类型强制转换。
```ts
let a: number = 5;
let b: string = "5";
console.log(a == b);    // true，进行类型强制转换后比较值
console.log(a === b);   // false，类型不同，不进行类型强制转换

let c: number = 5;
let d: number = 5;
console.log(c == d);    // true，类型相同，比较值
console.log(c === d);   // true，类型相同，比较值和类型

```
	不等运算符（`!=`和`!==`）：
	`!=`运算符用于比较两个值是否不相等，它会进行类型强制转换。
	`!==`运算符用于比较两个值是否不严格相等，不进行类型强制转换。
```ts
let a: number = 5;
let b: string = "5";
console.log(a != b);    // false，进行类型强制转换后比较值
console.log(a !== b);   // true，类型不同，不进行类型强制转换

let c: number = 5;
let d: number = 5;
console.log(c != d);    // false，类型相同，比较值
console.log(c !== d);   // false，类型相同，比较值和类型

```

#### 遍历
```ts
let nums: number[] = [1, 2, 3, 4, 5];
for (let i = 0; i < nums.length; i++) 
{
	console.log(nums[i]);
}
for(let num of nums)
{
	console.log(num);
}

let obj: { [key: string]: number } = { a: 1, b: 2, c: 3 };
for (let key in obj) 
{
	console.log(obj[key]);
}
```

#### 命名空间
- 命名空间用来组织代码和防止命名冲突的一种方式。它可以将相关的变量、函数、类等封装在一个独立的命名空间内
-   TypeScript：在TypeScript的命名空间中，如果要将某个成员（变量、函数、类等）暴露给外部使用，需要使用`export`关键字进行导出。
-   C++：在C++的命名空间中，没有类似TypeScript的`export`关键字，命名空间内的成员默认对外是可见的，不需要特别的导出操作
```ts
namespace MyNamespace 
{
  export const PI = 3.14159; //export关键词用于导出
  export class Person
  {
	  name: string;
  }
}

console.log(MyNamespace.PI); //用 . 符号
```

```cpp

namespace MyNamespace 
{
  const PI = 3.14159;  //无export
  class Person
  {
	  public: 
		  std::string name; 
  }; 
}

std::cout << MyNamespace::PI << std::endl; //用 :: 符号

```

#### 正则表达式
下面是 TypeScript/JavaScript 中正则表达式的一些基本规则：

1.  **字面量形式：** 使用 `/` 符号将正则表达式包含在斜杠之间。例如：`/pattern/`。
2.  **构造函数形式：** 使用 `RegExp` 构造函数来创建正则表达式对象。例如：`new RegExp('pattern')`。
3.  **元字符：** 元字符是用来匹配特定字符或字符类的特殊字符。例如：`.` 匹配任意字符，`\d` 匹配数字等。
4.  **字符类：** 字符类用于匹配一组字符中的任意一个字符。用方括号 `[]` 包含字符列表。例如：`[abc]` 匹配任意一个字符是 a、b 或 c。
5.  **量词：** 量词用于指定匹配字符出现的次数。例如：`*` 匹配 0 次或多次，`+` 匹配 1 次或多次，`?` 匹配 0 次或 1 次，`{n}` 匹配恰好 n 次，`{n, m}` 匹配至少 n 次，最多 m 次等。
6.  **分组：** 用小括号 `()` 可以将一系列字符组合为一个整体，并对整体应用量词或其他操作。例如：`(abc)*` 匹配 0 个或多个连续的 "abc"。

```ts
全数字:
^[0-9]$

电话号:
\d{3}-\d{8}|\d{4}-\d{7}

QQ号:
[1-9][0-9]{4,}

账号(字母开头，5-16位，允许字母数字下划线)
^[a-zA-Z][a-zA-Z0-9_]{4,15}$
```


## 函数

#### 函数声明： 
- 使用函数声明的方式是最常见的定义函数的方式
- 此时函数可以在任何地方调用
```ts
function functionName(parameters: parameterType): returnType 
{
  // 函数体
}
```

```ts
greet("Tom"); //可以在函数声明前使用

function greet(name: string): void 
{
  console.log(`Hello, ${name}!`);
}

greet("John"); // 输出：Hello, John!
```
#### 函数表达式： 
- 函数表达式是将函数赋值给一个变量或常量,此时这个函数名作为变量,
- 但是得在这个表达式之后调用
```ts
const functionName = function (parameters: parameterType): returnType 
{
  // 函数体
};
```

```ts
const greet = function (name: string): void 
{
  console.log(`Hello, ${name}!`);
};

greet("John"); // 输出：Hello, John!
```

#### 箭头函数
- 箭头函数是一种简化的函数表达式语法，适用于只有一个表达式的函数体
- 箭头函数可以通过`return`关键字返回值，也可以直接返回表达式的值。
	- 如果函数体只有一条表达式，并且省略了花括号`{}`，那么表达式的值就是函数的返回值。
	- 如果函数体有多条语句，或者需要执行其他逻辑，可以使用`return`关键字显式返回值。
```ts
const functionName = (parameters: parameterType): returnType => expression;
```

```ts
const greet = (name: string): void => console.log(`Hello, ${name}!`); 
greet("John"); // 输出：Hello, John!

const sayHello = () => {console.log("Hello");};
sayHello(); // Output: "Hello"

```

#### 回调函数
```ts
function func (value: Function)
{
	value();
}

//第一种,先定义好函数再传入
function test()
{
	console.log("test");
}
func(test); //传入函数名,也就是作为回调函数进行传参

//第二种,直接在参数列表里定义函数
func(function test(){console.log("test")});

	//第三种,直接在参数列表里定义函数,但是箭头函数,且展示一下回调函数里带有形参v`
func(function test()=>console.log("test"));
```

## 面向对象

1. **类（Class）**： 类是面向对象编程的基本构造单元，它是对象的蓝图，定义了对象的属性和方法。使用`class`关键字来声明一个类
```ts
class Person
{
	name:string="default";
	age:number=0;
	constructor(name: string,age:number) 
	{ 
		this.name = name; 
		this.age = age;
	}
	say()
	{
		document.write(this.name);
	}
}
```
2. **对象（Object）**： 对象是类的实例化结果，通过使用`new`关键字可以创建一个类的实例。
```ts
let a =new Person();
const b =new Person();
a.name="iota";
b.name="kappa";
```


#### 类的属性方法和对象的属性方法

3. **成员属性和成员函数**：

-   成员属性：成员属性是类的实例属性，每个类的实例都会有自己的一组属性。它们用于存储对象的状态和数据。
	成员属性在类的方法内部或构造函数中使用`this`关键字来访问，表示对当前对象的引用。每个类的实例都有自己的一份成员属性副本。
-   成员函数：成员函数也称为实例方法，是和特定对象实例相关联的方法。它们可以访问和操作对象的成员属性
	通过类的实例也就是对象来调用

4. **静态属性和静态函数**：

-   静态属性：静态属性是属于类本身的属性，而不是类的实例。它们在类的实例之间共享相同的值。
	静态属性在类的方法内部使用`className.propertyName`的形式进行访问。通常用于存储类级别的常量或共享数据。
-   静态函数：静态函数也称为类方法，它们属于类本身，而不是类的实例。因此，在静态函数内部不能访问类的实例成员，只能访问静态成员。
	静态函数通过类名来调用，而不是通过类的实例调用。
```ts

class MathUtils 
{
  static pi: number = 3.14159; // 静态属性,不属于类内的对象,而是属于类本身

  static circleArea(radius: number): number 
  { // 静态函数
    return this.pi * radius * radius;
  }
}

console.log(MathUtils.pi); // Output: 3.14159
console.log(MathUtils.circleArea(2)); // Output: 12.56636

const area = MathUtils.circleArea(radius); // 通过类名调用静态函数

```

#### 继承
- 允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。
- 继承能够帮助我们实现代码的重用，通过创建一个新类并从现有类继承功能，可以避免重复编写相似的代码。
```ts
// 定义一个基类 Animal
class Animal 
{
  name: string;

  constructor(name: string) 
  {
    this.name = name;
  }

  // 基类方法
  makeSound() 
  {
    console.log("Some generic sound");
  }
}

// 定义一个派生类 Dog，它继承了 Animal 类
class Dog extends Animal 
{
  // 可以在派生类中定义新的属性和方法
  breed: string;

  constructor(name: string, breed: string) 
  {
    // 调用父类的构造函数来初始化继承的属性
    super(name);
    this.breed = breed;
  }

  // 重写基类方法
  makeSound() //注意,会直接覆盖
  {
	//super.makeSound() 如果这样写的话,就不是覆盖,而是在原先基类的基础上进行拓展  
    console.log("Woof! Woof!");
  }

  // 新的派生类方法
  fetch() 
  {
    console.log("Fetching the ball...");
  }
}

// 创建一个 Dog 实例
const myDog = new Dog("Buddy", "Golden Retriever");

// 访问继承的属性和方法
console.log(myDog.name); // 输出: Buddy
myDog.makeSound(); // 输出: Woof! Woof!
myDog.fetch(); // 输出: Fetching the ball...

```

#### 抽象类
1.  抽象类不能直接实例化：无法通过 `new` 关键字直接创建抽象类的实例。只能用作其他类的父类。    
2.  抽象方法没有具体实现：抽象方法只有方法签名，没有方法体。子类继承抽象类后，必须实现抽象方法，否则子类也必须声明为抽象类。
3.  子类继承抽象类：子类通过使用 `extends` 关键字继承抽象类，并且需要实现抽象类中声明的抽象方法。
```ts
// 定义一个抽象类 Animal
abstract class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  // 抽象方法，没有具体实现,是需要继承的子类去具体实现的
  abstract makeSound(): void;

  // 普通方法
  move(distance: number) {
    console.log(`${this.name} moved ${distance} meters.`);
  }
}

// 定义一个派生类 Dog，它继承了 Animal 类
class Dog extends Animal {
  breed: string;

  constructor(name: string, breed: string) {
    super(name);
    this.breed = breed;
  }

  // 实现抽象方法
  makeSound() {
    console.log("Woof! Woof!");
  }
}

// 创建一个 Dog 实例
const myDog = new Dog("Buddy", "Golden Retriever");
myDog.makeSound(); // 输出: Woof! Woof!
myDog.move(10); // 输出: Buddy moved 10 meters.

```

#### 多态
- 多态性是指一个父类的引用变量（指针）可以指向其派生类的对象。这种灵活性使得可以通过父类的接口来操作不同的子类对象，而无需关心具体是哪个子类。
```ts
// 父类指针指向子类对象
let animal1: Animal = new Dog("Buddy", "Golden Retriever");
let animal2: Animal = new Cat("Whiskers", "Gray");

// 多态调用
animal1.makeSound(); // 输出: Woof! Woof!
animal2.makeSound(); // 输出: Meow!
```

#### 接口
- 定义接口： 在 TypeScript 中，通过 `interface` 关键字来定义接口
- // 通过在接口中定义 `sayHello` 方法，我们约定了对象必须实现这个方法。如果一个对象声明了实现了某个接口，那么该对象必须满足该接口的所有属性和方法的定义。
```ts
class Person 
{
	name: string;
	age: number;
	//sayHello: () => void;//`() => void`: 这是一个箭头函数类型的表达式。括号中的空参数列表 `()` 表示该方法不接受任何参数，而 `void` 表示该方法没有返回值。
}

interface IWolf()
{
	bark();//声明
}

interface IDog()
{
	eat();//声明
}

class wolfMan extends Person implements IWolf,IDog
{
	attack(){...};//定义
	eat(){...};//定义
}
```
- 可选属性： 接口中的属性可以用 `?` 符号标记为可选属性，表示该属性可以存在，也可以不存在。
```ts
interface Car 
{
  make: string;
  model: string;
  year?: number; // 可选属性
}
```
- 只读属性： 使用 `readonly` 关键字定义只读属性，一旦赋值后不能再被修改。
```ts
interface Point 
{
  readonly x: number;
  readonly y: number;
}
```
- 继承接口： 接口可以继承其他接口，从而扩展接口的定义。
```ts
interface Animal 
{
  type: string;
}

interface Dog extends Animal 
{
  breed: string;
}
```

#### 属性访问器
- 使用 `get` 和 `set` 关键字来创建属性访问器时，可以对属性进行赋值或获取操作,这两个是特殊的方法.
- 这种语法确实类似于赋值操作，但实际上是在调用属性访问器的方法，以获取或设置属性的值。。
```ts
class Circle 
{
  private _radius: number;////我们定义了一个名为`Circle`的类，其中有一个私有属性`_radius`。然后，我们使用属性访问器定义了`radius`属性的`get`和`set`方法。

  constructor(radius: number) //构造器
  {
    this._radius = radius;
  }

  // Getter
  get radius(): number //通过`get`方法，我们可以获取`_radius`的值，
  {
    return this._radius;
  }

  // Setter
  set radius(value: number) //而通过`set`方法，我们可以设置`_radius`的值，但在设置之前，我们会检查传入的值是否为非负数。
  {
    if (value >= 0) 
    {
      this._radius = value;
    } 
    else 
    {
      console.log("Radius cannot be negative.");//不能为负数
    }
  }

  // Computed property for calculating the area of the circle
  get area(): number //此外，我们还使用了一个计算属性`area`，它也是通过`get`方法计算得到的，它可以根据当前圆的半径自动计算圆的面积。
  {
    return Math.PI * this._radius * this._radius;
  }
}

const myCircle = new Circle(5);

console.log(myCircle.radius); // Output: 5

myCircle.radius = 10; // Setter is called

console.log(myCircle.radius); // Output: 10
console.log(myCircle.area); // Output: 314.1592653589793

```
- 上述的代码中，我们通过`get`和`set`关键字所构造的方法`radius`来对成员 `_radius` 进行取值赋值,
- 原则上我们仍然可以直接对成员`_radius`进行取值赋值,但是最好还是不要, 上述例子中的成员`_radius`也是直接进行了私有化, 需要通过类内方法进行取值赋值

#### 访问修饰符
1.  **public（默认）：** 如果成员没有指定访问修饰符，默认为 `public`，表示成员在类内部和外部都可访问。
2.  **private：** 使用 `private` 访问修饰符时，成员只能在类的内部访问，外部无法访问。
3.  **protected：** 使用 `protected` 访问修饰符时，成员可以在类的内部访问，也可以在派生类（子类）中访问，但在类的外部无法访问。
```ts

```

## 数组(Array)
#### 声明
```ts
const numbers: number[] = [1, 2, 3, 4, 5]; // 数字数组
console.log(numbers[0]); // 输出: 1

let names:string[]=["nb","bn"]; //字符数组
document.write(`这个数字是${name[0]}`); //输出: nb

const fruits: Array<string> = ['apple', 'banana', 'orange']; // 字符串数组
console.log(fruits.length); // 输出: 3

const mixed: Array<number | string> = [1, 'two', 3]; // 混合类型数组
console.log(mixed[1]); // 输出: 'two'

```
#### 内置函数
- `ts`的 `Array` 类没有计算数组长度的内置方法,但有一个属性可以访问到该数组的长度,也就是成员变量`length `,
```ts
const numbers = [1, 2, 3, 4, 5];
console.log(numbers.length); // Output: 5 (数组长度为5，即包含5个元素)
```
- **`push()`**：向数组末尾添加一个或多个元素，并返回新的数组长度。
```ts
const numbers: number[] = [1, 2, 3];
numbers.push(4); // [1, 2, 3, 4]
```
- **`pop()`**：移除并返回数组的最后一个元素。
```ts
const numbers: number[] = [1, 2, 3];
const lastElement = numbers.pop(); // 3
```
- **`shift()`**：移除并返回数组的第一个元素。
```ts
const numbers: number[] = [1, 2, 3];
const firstElement = numbers.shift(); // 1
```
- **`unshift()`**：向数组的开头添加一个或多个元素，并返回新的数组长度
```ts
const numbers: number[] = [2, 3, 4];
numbers.unshift(1); // [1, 2, 3, 4]
```
- **`concat()`**：合并两个或多个数组，返回新的合并后的数组。
```ts
const array1: number[] = [1, 2];
const array2: number[] = [3, 4];
const mergedArray = array1.concat(array2); // [1, 2, 3, 4]
```
- **`slice()`**：从数组中提取指定范围的元素，返回新的子数组。
```ts
const numbers: number[] = [1, 2, 3, 4, 5];
const subArray = numbers.slice(1, 4); // [2, 3, 4]
```
- **`indexOf()`**：返回指定元素在数组中首次出现的索引，如果不存在则返回 -1。
```ts
const numbers: number[] = [1, 2, 3, 4, 5];
const index = numbers.indexOf(3); // 2
```
- **`includes()`**：判断数组是否包含指定元素，返回布尔值。
```ts
const numbers: number[] = [1, 2, 3, 4, 5];
const hasThree = numbers.includes(3); // true
```
- **`forEach()`**：对数组中的每个元素执行指定的回调函数。
```ts
const numbers: number[] = [1, 2, 3];
numbers.forEach((num) => {console.log(num); // 1, 2, 3
```
- **`map()`** 对数组中的每个元素执行指定的回调函数，并返回一个新的数组。
```ts
const numbers: number[] = [1, 2, 3];
const doubledNumbers = numbers.map((num) => num * 2); // [2, 4, 6]
```
- **`findIndex()`**：查找数组中满足指定条件的第一个元素的索引，如果找不到返回 `-1`。
```ts
const numbers = [1, 2, 3, 4, 5];
const indexEven = numbers.findIndex((num) => num % 2 === 0);
console.log(indexEven); 
// Output: 1 (第一个偶数2的索引为1)

const indexGreaterThanThree = numbers.findIndex((num) => num > 3);
console.log(indexGreaterThanThree);
// Output: 3 (第一个大于3的数4的索引为3)
```
- **`find()`**：查找数组中满足指定条件的第一个元素，并返回该元素。
```ts
const numbers = [1, 2, 3, 4, 5];
const firstEven = numbers.find((num) => num % 2 === 0);
console.log(firstEven); // Output: 2 (第一个偶数为2)

const greaterThanThree = numbers.find((num) => num > 3);
console.log(greaterThanThree); // Output: 4 (第一个大于3的数为4)
```
- **`some()`**：检查数组中是否至少有一个元素满足指定条件，如果有则返回 `true`，否则返回 `false`。
```ts
const numbers = [1, 2, 3, 4, 5];
const hasNegative = numbers.some((num) => num < 0);
console.log(hasNegative); // Output: false (没有负数)

const hasEven = numbers.some((num) => num % 2 === 0);
console.log(hasEven); // Output: true (至少有一个偶数)
```
- **`every()`**：检查数组中的所有元素是否满足指定条件，如果所有元素满足条件则返回 `true`，否则返回 `false`。
```ts
const numbers = [1, 2, 3, 4, 5];
const allPositive = numbers.every((num) => num > 0);
console.log(allPositive); // Output: true (所有元素都大于0)

const allEven = numbers.every((num) => num % 2 === 0);
console.log(allEven); // Output: false (并非所有元素都是偶数)
```
- **`reduce()`**：对数组中的元素进行累积操作，返回一个累积结果。
```ts
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
console.log(sum); // Output: 15 (1 + 2 + 3 + 4 + 5 = 15)
```
- `reverse()` 方法会返回颠倒后的数组，即原数组中的最后一个元素会成为新数组的第一个元素，倒数第二个元素会成为新数组的第二个元素，以此类推。
	-  需要注意的是，`reverse()` 方法会修改原始数组，所以在使用该方法之后，原始数组的顺序会被改变。如果不希望改变原始数组，可以在操作前先复制数组或使用其他方式来保存原数组。
```ts
const fruits = ["apple", "banana", "orange", "grape"];
fruits.reverse();
console.log(fruits);
// Output: ["grape", "orange", "banana", "apple"] (数组元素颠倒)


const numbers = [1, 2, 3, 4, 5];
const reversedNumbers = numbers.slice().reverse(); // 先复制数组再进行 reverse
console.log(reversedNumbers); // Output: [5, 4, 3, 2, 1]

console.log(numbers); // Output: [1, 2, 3, 4, 5] (原数组顺序不变)
```
- **`sort()`** : 默认情况下会将数组元素视为字符串并按照 Unicode 码点进行排序。
	- 如果数组中的元素是字符串类型，它将按照字母顺序排序。
	- 如果数组中的元素是数字类型，它将按照数值大小进行排序。
	- 可以通过传递一个比较函数来自定义排序规则。
```ts
// 数字数组排序示例
const numbers = [5, 1, 3, 2, 4];
numbers.sort();
console.log(numbers); // Output: [1, 2, 3, 4, 5] (按照 Unicode 码点排序)

// 字符串数组排序示例
const fruits = ["apple", "orange", "banana", "grape"];
fruits.sort();
console.log(fruits); // Output: ["apple", "banana", "grape", "orange"] (按照字母顺序排序)

// 自定义排序规则示例
const people = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Eve", age: 35 }
];

people.sort((a, b) => a.age - b.age); // 按照年龄升序排序
console.log(people);
// Output: [
//   { name: "Bob", age: 25 },
//   { name: "Alice", age: 30 },
//   { name: "Eve", age: 35 }
// ]

people.sort((a, b) => b.age - a.age); // 按照年龄降序排序
console.log(people);
// Output: [
//   { name: "Eve", age: 35 },
//   { name: "Alice", age: 30 },
//   { name: "Bob", age: 25 }
// ]

```
## 元组(Tuple)

#### TS与PY元组的区别

1.  **可变性**：
    -   Python：元组是不可变的，一旦创建后，就不能修改其中的元素。
    -   TypeScript：元组是可变的，可以通过索引访问和修改其中的元素。
2.  **创建方式**：
    -   Python：元组使用圆括号`()`来创建，元素之间用逗号`,`分隔。例如：`(1, 'hello', True)`。
    -   TypeScript：元组使用方括号`[]`来定义，元素之间用逗号`,`分隔。例如：`[1, 'hello', true]`。
3.  **类型约束**：
    -   Python：Python是一种动态类型语言，元组中的元素可以是任意类型，不需要显式指定类型。例如，元组可以包含整数、字符串、布尔值等不同类型的元素。
    -   TypeScript：TypeScript是一种静态类型语言，元组中的元素可以是不同类型，但在定义元组类型时，需要使用泛型（例如：`[number, string, boolean]`）或接口（例如：`[Person, number]`）明确指定元素的类型。
4.  **使用场景**：
    -   Python：元组常用于在函数返回多个值时，作为函数的返回值。由于元组是不可变的，因此可以在不希望修改返回值的情况下使用元组。
    -   TypeScript：元组常用于表示固定长度和类型的数据结构，例如，一个点的坐标可以使用元组表示为`[number, number]`，其中第一个元素为x坐标，第二个元素为y坐标。

#### TS中数组和元组的区别

```ts
// 数组示例
let numberArray: number[] = [1, 2, 3, 4, 5]; // 数字数组
let stringArray: string[] = ["apple", "banana", "orange"]; // 字符串数组

// 在运行时增加数组元素
numberArray.push(6);
stringArray.push("grape");

console.log(numberArray); // Output: [1, 2, 3, 4, 5, 6]
console.log(stringArray); // Output: ["apple", "banana", "orange", "grape"]

// 元组示例
let myTuple: [number, string, boolean] = [1, "hello", true];

// 尝试修改元组的值
myTuple[0] = 10; //元组的元素可变,但长度和类型固定

// 尝试增加元组元素
myTuple.push(false); // 编译错误，元组的长度是固定的

console.log(myTuple); // Output: [1, "hello", true]

```

## 字典(Dictionary)

```ts
//键是string类型,值也是string类型
let dic : { [ket:string]: string } =
{
	"name1": "odddouglas",
	"name2": "iota"
};
dic["name2"]="kappa"; //修改
dic["name3"]="beta"; //新增

console.log(dic["name3"]);

// 删除键值对 
delete studentDict[1003]; 

// 遍历字典的键值对 
for (const key in studentDict) 
{ 
	console.log(`Key: ${key}, Value: ${studentDict[key]}`
);
```

## 模式

#### 单例模式(Singleton Pattern)
- **单例模式**是一种设计模式，其目的是确保一个类只有一个实例，并提供一个全局访问点来访问该实例。这意味着无论在应用程序的任何地方都可以获取到同一个类的唯一实例。
- 常见的应用场景是在需要共享资源、配置或状态的情况下。通过使用单例模式，可以避免多次创建重复的实例，节省资源并确保全局只有一个实例存在

- 简单的单例模式,但是该单例会直接附带生成
```ts
class SoundManager 
{
  static Instance = new SoundManager(); // 类的属性(即静态属性)

  private constructor() 
  {
    // 私有构造函数，防止外部实例化
  }

  playSound(soundName: string): void 
  {
    console.log(`Playing sound: ${soundName}`);
    // 在实际应用中可能会有更多的逻辑来播放声音
  }
}

// //直接类名调用该属性,而该属性是一个SoundManager的唯一实例,即实现单例模式
const soundManager = SoundManager.Instance;

// 由于构造函数是私有的，不能直接使用 new 关键字来实例化
// const soundManager = new SoundManager(); // Error: 'constructor' is private.

// 使用单例实例来播放声音
soundManager.playSound("background_music"); // Output: "Playing sound: background_music"

// 尝试获取另一个实例，但实际上会得到之前获取的同一个实例
const anotherSoundManager = SoundManager.Instance;
console.log(soundManager === anotherSoundManager); // Output: true，两个实例是同一个对象

```

- 懒加载模式, 只有在调用 `getInstance` 时才会生成该类的单例
```ts
class Logger 
{
  private static instance: Logger | null = null;

  private constructor() 
  {
    // 私有构造函数，防止外部实例化
  }

  public static getInstance(): Logger 
  {
    if (!Logger.instance) 
    {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  public log(message: string): void 
  {
    console.log(message);
  }
}

// 获取Logger类的唯一实例
const logger1 = Logger.getInstance();
const logger2 = Logger.getInstance();

console.log(logger1 === logger2); // Output: true，两个实例是同一个对象

logger1.log("Hello from logger1!"); // Output: "Hello from logger1!"
logger2.log("Hello from logger2!"); // Output: "Hello from logger2!"

```

#### 代理模式(Proxy Pattern)

- 允许通过代理对象来控制对另一个对象的访问。代理模式主要用于增加额外的控制和功能，而无需修改原始对象的代码。

代理模式通常由两个角色组成：

1.  **主题（Subject）：** 主题是一个接口，定义了真实对象和代理对象共同的接口，使得代理对象可以替代真实对象，并实现相同的接口。
2.  **代理（Proxy）：** 代理是一个代替真实对象的对象，它持有对真实对象的引用，并在需要时将调用传递给真实对象。代理还可以添加额外的逻辑或控制，如延迟加载、权限验证等。

```ts
interface ICalc //主题
{
	calc(num1,num2):number;
}

class Proxy1 implements ICalc //代理1
{
	calc(num1,num2)
	{
		return num1+num2;
	}
}

class Proxy2 implements ICalc //代理2
{
	clac(num1,num2)
	{
		return num1*num2;
	}
}

class Sum
{
	delegate: ICalc; 
	//创建一个 `delegate` Sum类属性，类型为 `ICalc` 接口类 的对象
	GetNum(num1,num2) 
	//创建一个 `GetNum` Sum类方法
	{
		let num = this.delegate.clac(num1,num2);
		//通过调用 对象`delegate` 的 `calc` 方法，
		doucment.write(num+ "");
		//计算完之后打印出来结果
	}
}

let sum = new Sum();
//创建一个类型为 Sum类 的对象sum
sum.delegate = new Proxy1(); 
//让类型为 ICalc接口 的属性接收代理1的接口函数,其实此时delegate就变成了Proxy代理接口类的对象
sum.GetNum(3,4);
//此时Sum类对象sum中的Proxy1类对象delegate可以调用类方法clac

```

#### 观察者模式(Observer Pattern)

- 用于在对象之间建立一种一对多的依赖关系，当一个对象的状态发生变化时，它的所有依赖者（观察者）都会收到通知并自动更新。

```ts
interface IObserver
{
	nameChanged(newName);//要求接入该接口的类必须拥有该函数
}

class Person
{
	private _name: string;//创建一个私有属性,如果发生变化,则向所有观察者发送消息

	observer : Array<IObserver> = new Array<IObserver>();
	//创建一个数组,该数组存储着遵循观察者协议的类,里面存放的都是观察者
	
	set name(value)
	{
		this._name = value; 
		//一旦被监听者的私有属性发生变化,就向所有的观察者发送信息
		for (let observer of this.observers)
		{
			observer.nameChanged(this._name);
		}
	}
	get name(value)
	{
		return this._name;
	}
}

class Test implements IObserver //遵循IObserver接口协议的Test类
{
	nameChanged(newName)//打印监听者接收到的消息
	{
		document.write("name changed to"+ newName);
	}
}

let person = new Person(); //设置被监听对象
let OB1 = new Test(); //设置观察者1号

person.observers.push(test);//将观察者1号塞进观察者数组中

person.name = "iota"; //利用set关键字的方法来修改被监听者的对象中的内容
```

#### 工厂模式(Factory Pattern)
- 简单工厂模式并不是一种正式的设计模式，它更像是一种编程习惯。通常是创建一个工厂类，根据传入的参数来创建不同类型的对象
- 不需要直接使用 `new` 关键字来实例化对象，而是通过调用工厂方法来获取实例。
```ts
enum CharType
{
	Bmw,
	Audi,
	Benz
}

class Car
{
	name:string;
	//工厂模式
	static Create (carType : CarType) : Car //一个枚举类型CarType的形参carType,返回值是Car类的对象
	{
		let car : Car;
		switch (carType)
		{
			case CarType.Bmw:
				car = new Bmw();
				break;
			case CarType.Audi:
				car = new Audi();
				break;
			case CarType.Benz:
				car = new Benz();
				break;
		}
		return car; //将生成对应指定类型的汽车返回
	}
}

class Bmw extends Car{...}
class Benz extends Car{...}
class Audi extends Car{...}

let bmw = Car.Create(CarType.Bmw);
let audi = Car.Create(CarType.Audi);
let benz = Car.Create(CarType.Benz);

```

#### 链表

```ts
class Person
{
	name : string;
	next : Person; //定义一个next对象

	constructor(name)
	{
		this.name = name;
	}
}

let person = new Person("iota");
person.next = new Person("kappa");
person.next.next = new Person("odddouglas");

//链表遍历
while(person)
{
	document.write(person.name);
	person = person.next;
}

//删除
person.next = person.next.next; 

//插入
let tmpPerson = new Person("nb");
tmpPerson.next = person.next;
person.next = tmpPerson;
```